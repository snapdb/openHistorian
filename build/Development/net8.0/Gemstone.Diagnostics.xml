<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Gemstone.Diagnostics</name>
    </assembly>
    <members>
        <member name="T:Gemstone.Diagnostics.ChildProcessManager">
            <summary>
            Represents a manager for automatically terminating child processes.
            </summary>
        </member>
        <member name="E:Gemstone.Diagnostics.ChildProcessManager.TerminationException">
            <summary>
            Raised when there is an exception while attempting to terminate child process.
            </summary>
            <remarks>
            This is currently only raised on non-Windows operating systems.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.ChildProcessManager.#ctor">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.ChildProcessManager"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ChildProcessManager.Finalize">
            <summary>
            Make sure child processes get disposed.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ChildProcessManager.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Diagnostics.ChildProcessManager"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ChildProcessManager.AddProcess(System.Diagnostics.Process)">
            <summary>
            Associates the specified <paramref name="process"/> as a child of this <see cref="T:Gemstone.Diagnostics.ChildProcessManager"/> instance.
            </summary>
            <param name="process">The <see cref="T:System.Diagnostics.Process"/> to associate.</param>
            <remarks>
            <para>
            The <paramref name="process"/> will be managed as an associated process of this <see cref="T:Gemstone.Diagnostics.ChildProcessManager"/>
            instance. When this <see cref="T:Gemstone.Diagnostics.ChildProcessManager"/> instance is disposed or garbage collected, the children
            processes will be terminated.
            </para>
            <para>
            Creating an instance of this class with lifetime scope of the executing application will cause any child processes
            to be terminated when the parent process shuts down, on Windows environments this will happen even when the parent
            process termination is abnormal.
            </para>
            </remarks>
        </member>
        <member name="T:Gemstone.Diagnostics.DisposableLoggingClassBase">
            <summary>
            A helper class that implements <see cref="T:System.IDisposable"/> that will raise log messages
            when this class is not properly disposed of.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.DisposableLoggingClassBase.Log">
            <summary>
            The <see cref="T:Gemstone.Diagnostics.LogPublisher"/> for logging messages.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.DisposableLoggingClassBase.#ctor(Gemstone.Diagnostics.MessageClass)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.DisposableLoggingClassBase"/>
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.DisposableLoggingClassBase.Finalize">
            <summary>
            This code is here to detect when finalizers are called rather than a class be properly disposed. 
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.DisposableLoggingClassBase.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Diagnostics.DisposableLoggingClassBase"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.DisposableLoggingClassBase.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Diagnostics.DisposableLoggingClassBase"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.DisposableLoggingClassBase.CheckDisposed">
            <summary>
            Checks if the class has been disposed, throws an exception if this is the case.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject">
            <summary>
            Represents an object that can be configured as read only and thus made immutable.  
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject.IsReadOnly">
            <summary>
            Get/Sets if a class is readonly.  Once it has been set as readonly, it is immutable and must be cloned to me modified.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject.CloneEditable">
            <summary>
            Makes a clone of this object and allows it to be edited.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject.CloneReadonly">
            <summary>
            Makes a readonly clone of this object. Returns the same object if it is already marked as readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject`1">
            <summary>
            Represents an object that can be configured as read only and thus made immutable.  
            The origional contents of this class will not be editable once <see cref="P:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject.IsReadOnly"/> is set to true.
            In order to modify the contest of this object, a clone of the object must be created with <see cref="M:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject`1.CloneEditable"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject`1.CloneEditable">
            <summary>
            Makes a clone of this object and allows it to be edited.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject`1.CloneReadonly">
            <summary>
            Makes a readonly clone of this object. Returns the same object if it is already marked as readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1">
            <summary>
            A array that can be modified until <see cref="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.IsReadOnly"/> is set to true. Once this occurs,
            the array itself can no longer be modified.  Remember, this does not cause objects contained in this class to be Immutable 
            unless they implement <see cref="T:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.#ctor(System.Int32,System.Func{`0,`0})">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0})">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.Contains(`0)">
            <summary>Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.</summary>
            <returns>true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.</returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.Count">
            <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.SetMembersAsReadOnly">
            <summary>
            Sets members as readonly 
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.CloneMembersAsEditable">
            <summary>
            CloneMembersAsEditable
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.IndexOf(`0)">
            <summary>Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.</summary>
            <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.</summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <summary>Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.</summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableArray`1.Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <returns>The element at the specified index.</returns>
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2">
            <summary>
            A dictionary that can be modified until <see cref="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.IsReadOnly"/> is set to true. Once this occurs,
            the dictionary itself can no longer be modified.  Remember, this does not cause objects contained in this class to be Immutable 
            unless they implement <see cref="T:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject"/>.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.#ctor">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.#ctor(System.Collections.Generic.Dictionary{`0,`1})">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Clear">
            <summary>Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.</summary>
            <returns>true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.</returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Count">
            <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.SetMembersAsReadOnly">
            <summary>
            SetMembersAsReadOnly
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.CloneMembersAsEditable">
            <summary>
            CloneMembersAsEditable
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key.</summary>
            <returns>true if the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the key; otherwise, false.</returns>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Add(`0,`1)">
            <summary>Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Remove(`0)">
            <summary>Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
            <returns>true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key" /> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.TryGetValue(`0,`1@)">
            <summary>Gets the value associated with the specified key.</summary>
            <returns>true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key; otherwise, false.</returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed uninitialized.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Item(`0)">
            <summary>Gets or sets the element with the specified key.</summary>
            <returns>The element with the specified key.</returns>
            <param name="key">The key of the element to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="key" /> is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and <paramref name="key" /> is not found.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Keys">
            <summary>Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableDictionary`2.Values">
            <summary>Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" />.</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1">
            <summary>
            A list that can be modified until <see cref="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.IsReadOnly"/> is set to true. Once this occurs,
            the list itself can no longer be modified.  Remember, this does not cause objects contained in this class to be Immutable 
            unless they implement <see cref="T:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.#ctor(System.Func{`0,`0})">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1"/>.
            </summary>
            <param name="formatter">Allows items to be formatted when inserted into a list.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.#ctor(System.Int32,System.Func{`0,`0})">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Add(`0)">
            <summary>Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the specified collection to the end of the <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="collection">The collection whose elements should be added to the end of the <see cref="T:System.Collections.Generic.List`1"/>. 
            The collection itself cannot be null, but it can contain elements that are null</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Clear">
            <summary>Removes all items from the collection.</summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Contains(`0)">
            <summary>Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.</summary>
            <returns>true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.</returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary>
            <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Remove(`0)">
            <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Count">
            <summary>Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
            <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.SetMembersAsReadOnly">
            <summary>
            Requests that member fields be set to readonly. 
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.CloneMembersAsEditable">
            <summary>
            Request that member fields be cloned and marked as editable.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.IndexOf(`0)">
            <summary>Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.</summary>
            <returns>The index of <paramref name="item" /> if found in the list; otherwise, -1.</returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Insert(System.Int32,`0)">
            <summary>Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.</summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.RemoveAt(System.Int32)">
            <summary>Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.</summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableList`1.Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <returns>The element at the specified index.</returns>
            <param name="index">The zero-based index of the element to get or set.</param>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectAutoBase`1">
            <summary>
            Represents an object that can be configured as read only and thus made immutable.  
            This class will automatically clone any field that implements <see cref="T:Gemstone.Diagnostics.Internal.Immutable.IImmutableObject"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectAutoBase`1.SetMembersAsReadOnly">
            <summary>
            Requests that member fields be set to readonly. 
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectAutoBase`1.CloneMembersAsEditable">
            <summary>
            Request that member fields be cloned and marked as editable.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1">
            <summary>
            Represents an object that can be configured as read only and thus made immutable.  
            The origional contents of this class will not be editable once <see cref="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.IsReadOnly"/> is set to true.
            In order to modify the contest of this object, a clone of the object must be created with <see cref="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.CloneEditable"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            For a classes that implement this, all setters should call <see cref="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.TestForEditable"/> before 
            setting the value. 
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.IsReadOnly">
            <summary>
            Gets/Sets if this class is immutable and thus read only. Once
            setting to readonly, the class becomes immutable.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.TestForEditable">
            <summary>
            Test if the class has been marked as readonly. Throws an exception if editing cannot occur.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.SetMembersAsReadOnly">
            <summary>
            Requests that member fields be set to readonly. 
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.CloneMembersAsEditable">
            <summary>
            Request that member fields be cloned and marked as editable.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.CloneEditable">
            <summary>
            Creates a clone of this class that is editable.
            A clone is always created, even if this class is already editable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.Gemstone#Diagnostics#Internal#Immutable#IImmutableObject#CloneReadonly">
            <summary>
            Makes a readonly clone of this object. Returns the same object if it is already marked as readonly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.Gemstone#Diagnostics#Internal#Immutable#IImmutableObject#CloneEditable">
            <summary>
            Makes a clone of this object and allows it to be edited.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.CloneReadonly">
            <summary>
            Makes a readonly clone of the object.
            If the class is currently marked as readonly, the current instance is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Immutable.ImmutableObjectBase`1.Clone">
            <summary>
            Returns a clone of this class.
            If the class is marked as readonly, it returns the current instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32">
            <summary>
              Computes a CRC-32. The CRC-32 algorithm is parameterized - you
              can set the polynomial and enable or disable bit
              reversal. This can be used for GZIP, BZip2, or ZIP.
            </summary>
            <remarks>
              This type is used internally by DotNetZip; it is generally not used
              directly by applications wishing to create, read, or manipulate zip
              archive files.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.TotalBytesRead">
            <summary>
              Indicates the total number of bytes applied to the CRC.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.Crc32Result">
            <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream, and writes the input into the
            output stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <param name="output">The stream into which to deflate the input</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.ComputeCrc32(System.Int32,System.Byte)">
            <summary>
              Get the CRC32 for the given (word,byte) combo.  This is a
              computation defined by PKzip for PKZIP 2.0 (weak) encryption.
            </summary>
            <param name="W">The word to start with.</param>
            <param name="B">The byte to combine it with.</param>
            <returns>The CRC-ized result.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
            <param name="block">block of bytes to slurp</param>
            <param name="offset">starting point in the block</param>
            <param name="count">how many bytes within the block to slurp</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.UpdateCRC(System.Byte)">
            <summary>
              Process one byte in the CRC.
            </summary>
            <param name = "b">the byte to include into the CRC .  </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.UpdateCRC(System.Byte,System.Int32)">
            <summary>
              Process a run of N identical bytes into the CRC.
            </summary>
            <remarks>
              <para>
                This method serves as an optimization for updating the CRC when a
                run of identical bytes is found. Rather than passing in a buffer of
                length n, containing all identical bytes b, this method accepts the
                byte value and the length of the (virtual) buffer - the length of
                the run.
              </para>
            </remarks>
            <param name = "b">the byte to include into the CRC.  </param>
            <param name = "n">the number of times that byte should be repeated. </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.Combine(System.Int32,System.Int32)">
            <summary>
              Combines the given CRC32 value with the current running total.
            </summary>
            <remarks>
              This is useful when using a divide-and-conquer approach to
              calculating a CRC.  Multiple threads can each calculate a
              CRC32 on a segment of the data, and then combine the
              individual CRC32 values at the end.
            </remarks>
            <param name="crc">the crc value to be combined with this one</param>
            <param name="length">the length of data the CRC value was calculated on</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.#ctor">
            <summary>
              Create an instance of the CRC32 class using the default settings: no
              bit reversal, and a polynomial of 0xEDB88320.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.#ctor(System.Boolean)">
            <summary>
              Create an instance of the CRC32 class, specifying whether to reverse
              data bits or not.
            </summary>
            <param name='reverseBits'>
              specify true if the instance should reverse data bits.
            </param>
            <remarks>
              <para>
                In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                want a CRC32 with compatibility with BZip2, you should pass true
                here. In the CRC-32 used by GZIP and PKZIP, the bits are not
                reversed; Therefore if you want a CRC32 with compatibility with
                those, you should pass false.
              </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.#ctor(System.Int32,System.Boolean)">
             <summary>
               Create an instance of the CRC32 class, specifying the polynomial and
               whether to reverse data bits or not.
             </summary>
             <param name='polynomial'>
               The polynomial to use for the CRC, expressed in the reversed (LSB)
               format: the highest ordered bit in the polynomial value is the
               coefficient of the 0th power; the second-highest order bit is the
               coefficient of the 1 power, and so on. Expressed this way, the
               polynomial for the CRC-32C used in IEEE 802.3, is 0xEDB88320.
             </param>
             <param name='reverseBits'>
               specify true if the instance should reverse data bits.
             </param>
            
             <remarks>
               <para>
                 In the CRC-32 used by BZip2, the bits are reversed. Therefore if you
                 want a CRC32 with compatibility with BZip2, you should pass true
                 here for the <c>reverseBits</c> parameter. In the CRC-32 used by
                 GZIP and PKZIP, the bits are not reversed; Therefore if you want a
                 CRC32 with compatibility with those, you should pass false for the
                 <c>reverseBits</c> parameter.
               </para>
             </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32.Reset">
            <summary>
              Reset the CRC-32 class - clear the CRC "remainder register."
            </summary>
            <remarks>
              <para>
                Use this when employing a single instance of this class to compute
                multiple, distinct CRCs on multiple, distinct data blocks.
              </para>
            </remarks>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream">
             <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read,
             or on all bytes written.
             </summary>
            
             <remarks>
             <para>
             This class can be used to verify the CRC of a ZipEntry when
             reading from a stream, or to calculate a CRC when writing to a
             stream.  The stream should be used to either read, or write, but
             not both.  If you intermix reads and writes, the results are not
             defined.
             </para>
            
             <para>
             This class is intended primarily for use internally by the
             DotNetZip library.
             </para>
             </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream)">
            <summary>
            The default constructor.
            </summary>
            <remarks>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().  The stream uses the default CRC32
                algorithm, which implies a polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
              The constructor allows the caller to specify how to handle the
              underlying stream at close.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read.
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
              <para>
                Instances returned from this constructor will leave the underlying
                stream open upon Close().
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close().
            </summary>
            <remarks>
              <para>
                The stream uses the default CRC32 algorithm, which implies a
                polynomial of 0xEDB88320.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64,System.Boolean,Gemstone.Diagnostics.Internal.Ionic.Zlib.CRC32)">
            <summary>
              A constructor allowing the specification of the length of the stream
              to read, as well as whether to keep the underlying stream open upon
              Close(), and the CRC32 instance to use.
            </summary>
            <remarks>
              <para>
                The stream uses the specified CRC32 instance, which allows the
                application to specify how the CRC gets calculated.
              </para>
            </remarks>
            <param name="stream">The underlying stream</param>
            <param name="length">The length of the stream to slurp</param>
            <param name="leaveOpen">true to leave the underlying stream
            open upon close of the <c>CrcCalculatorStream</c>; false otherwise.</param>
            <param name="crc32">the CRC32 instance to use to calculate the CRC32</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.TotalBytesSlurped">
             <summary>
               Gets the total number of bytes run through the CRC32 calculator.
             </summary>
            
             <remarks>
               This is either the total number of bytes read, or the total number of
               bytes written, depending on the direction of this stream.
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Crc">
            <summary>
              Provides the current CRC for all blocks slurped in.
            </summary>
            <remarks>
              <para>
                The running total of the CRC is kept as data is written or read
                through the stream.  read this property after all reads or writes to
                get an accurate CRC for the entire stream.
              </para>
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.LeaveOpen">
            <summary>
              Indicates whether the underlying stream will be left open when the
              <c>CrcCalculatorStream</c> is Closed.
            </summary>
            <remarks>
              <para>
                Set this at any point before calling <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Close"/>.
              </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">the buffer to read</param>
            <param name="offset">the offset at which to start</param>
            <param name="count">the number of bytes to read</param>
            <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream.
            </summary>
            <param name="buffer">the buffer from which to write</param>
            <param name="offset">the offset at which to start writing</param>
            <param name="count">the number of bytes to write</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.CanRead">
            <summary>
            Indicates whether the stream supports reading.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.CanSeek">
            <summary>
              Indicates whether the stream supports seeking.
            </summary>
            <remarks>
              <para>
                Always returns false.
              </para>
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.CanWrite">
            <summary>
            Indicates whether the stream supports writing.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Length">
            <summary>
              Returns the length of the underlying stream.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Position">
            <summary>
              The getter for this property returns the total bytes read.
              If you use the setter, it will throw
            <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeking is not supported on this stream. This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="offset">N/A</param>
            <param name="origin">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.SetLength(System.Int64)">
            <summary>
            This method always throws
            <see cref="T:System.NotSupportedException"/>
            </summary>
            <param name="value">N/A</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.CrcCalculatorStream.Close">
            <summary>
            Closes the stream.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream">
             <summary>
             A class for compressing and decompressing streams using the Deflate algorithm.
             </summary>
            
             <remarks>
            
             <para>
               The DeflateStream is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
               cref="T:System.IO.Stream"/>.  It adds DEFLATE compression or decompression to any
               stream.
             </para>
            
             <para>
               Using this stream, applications can compress or decompress data via stream
               <c>Read</c> and <c>Write</c> operations.  Either compresssion or decompression
               can occur through either reading or writing. The compression format used is
               DEFLATE, which is documented in <see
               href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
               Compressed Data Format Specification version 1.3.".
             </para>
            
             <para>
               This class is similar to <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream"/>, except that
               <c>ZlibStream</c> adds the <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
               1950 - ZLIB</see> framing bytes to a compressed stream when compressing, or
               expects the RFC1950 framing bytes when decompressing. The <c>DeflateStream</c>
               does not.
             </para>
            
             </remarks>
            
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream" />
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode)">
             <summary>
               Create a DeflateStream using the specified CompressionMode.
             </summary>
            
             <remarks>
               When mode is <c>CompressionMode.Compress</c>, the DeflateStream will use
               the default compression level. The "captive" stream will be closed when
               the DeflateStream is closed.
             </remarks>
            
             <example>
             This example uses a DeflateStream to compress data from a file, and writes
             the compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel)">
             <summary>
             Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.  The "captive" stream will be closed when the DeflateStream is
               closed.
             </para>
            
             </remarks>
            
             <example>
            
               This example uses a DeflateStream to compress data from a file, and writes
               the compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".deflated"))
                 {
                     using (Stream compressor = new DeflateStream(raw,
                                                                  CompressionMode.Compress,
                                                                  CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".deflated")
                     Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>DeflateStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified
               <c>CompressionMode</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compression.  Specify true for
               the <paramref name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               The <c>DeflateStream</c> will use the default compression level.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the
               "captive" stream in other places in this documentation.
             </param>
            
             <param name="mode">
               Indicates whether the <c>DeflateStream</c> will compress or decompress.
             </param>
            
             <param name="leaveOpen">true if the application would like the stream to
             remain open after inflation/deflation.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>DeflateStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify whether
               the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter
               to leave the stream open.
             </para>
            
             </remarks>
            
             <example>
            
               This example shows how to use a <c>DeflateStream</c> to compress data from
               a file, and store the compressed data into another file.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".deflated"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n= -1;
                         while (n != 0)
                         {
                             if (n &gt; 0)
                                 compressor.Write(buffer, 0, n);
                             n= input.Read(buffer, 0, buffer.Length);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
            
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".deflated")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New DeflateStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
            <remarks> See the ZLIB documentation for the meaning of the flush behavior.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
             <remarks>
               By tweaking this parameter, you may be able to optimize the compression for
               data with particular characteristics.
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                Application code won't call this code directly.  This method may be
                invoked in two distinct scenarios.  If disposing == true, the method
                has been called directly or indirectly by a user's code, for example
                via the public Dispose() method. In this case, both managed and
                unmanaged resources can be referenced and disposed.  If disposing ==
                false, the method has been called by the runtime from inside the
                object finalizer and this method should not reference other objects;
                in that case only unmanaged resources must be referenced or
                disposed.
              </para>
            </remarks>
            <param name="disposing">
              true if the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Position">
             <summary>
             The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, providing an uncompressed data stream.
               Then call Read() on that <c>DeflateStream</c>, and the data read will be
               compressed as you read.  If you wish to use the <c>DeflateStream</c> to
               decompress data while reading, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, providing a readable compressed data
               stream.  Then call Read() on that <c>DeflateStream</c>, and the data read
               will be decompressed as you read.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
            
             </remarks>
             <param name="buffer">The buffer into which the read data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">this is irrelevant, since it will always throw!</param>
            <param name="origin">this is irrelevant, since it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">this is irrelevant, since it will always throw!</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
             <remarks>
            
             <para>
               If you wish to use the <c>DeflateStream</c> to compress data while
               writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Compress</c>, and a writable output stream.  Then call
               <c>Write()</c> on that <c>DeflateStream</c>, providing uncompressed data
               as input.  The data sent to the output stream will be the compressed form
               of the data written.  If you wish to use the <c>DeflateStream</c> to
               decompress data while writing, you can create a <c>DeflateStream</c> with
               <c>CompressionMode.Decompress</c>, and a writable output stream.  Then
               call <c>Write()</c> on that stream, providing previously compressed
               data. The data sent to the output stream will be the decompressed form of
               the data written.
             </para>
            
             <para>
               A <c>DeflateStream</c> can be used for <c>Read()</c> or <c>Write()</c>,
               but not both.
             </para>
            
             </remarks>
            
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using DEFLATE (RFC 1951).
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressString(System.String)">GZipStream.CompressString(string)</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressString(System.String)">ZlibStream.CompressString(string)</seealso>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using DEFLATE.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(string)</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">GZipStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">ZlibStream.CompressBuffer(byte[])</seealso>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a single string.
             </summary>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CompressString(System.String)">DeflateStream.CompressString(String)</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">DeflateStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">GZipStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">ZlibStream.UncompressString(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing DEFLATE-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a DEFLATE'd byte array into a byte array.
             </summary>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.CompressBuffer(System.Byte[])">DeflateStream.CompressBuffer(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream.UncompressString(System.Byte[])">DeflateStream.UncompressString(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">GZipStream.UncompressBuffer(byte[])</seealso>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">ZlibStream.UncompressBuffer(byte[])</seealso>
            
             <param name="compressed">
               A buffer containing data that has been compressed with DEFLATE.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream">
             <summary>
               A class for compressing and decompressing GZIP streams.
             </summary>
             <remarks>
            
             <para>
               The <c>GZipStream</c> is a <see
               href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a
               <see cref="T:System.IO.Stream"/>. It adds GZIP compression or decompression to any
               stream.
             </para>
            
             <para>
               Like the <c>System.IO.Compression.GZipStream</c> in the .NET Base Class Library, the
               <c>Ionic.Zlib.GZipStream</c> can compress while writing, or decompress while
               reading, but not vice versa.  The compression method used is GZIP, which is
               documented in <see href="http://www.ietf.org/rfc/rfc1952.txt">IETF RFC
               1952</see>, "GZIP file format specification version 4.3".</para>
            
             <para>
               A <c>GZipStream</c> can be used to decompress data (through <c>Read()</c>) or
               to compress data (through <c>Write()</c>), but not both.
             </para>
            
             <para>
               If you wish to use the <c>GZipStream</c> to compress data, you must wrap it
               around a write-able stream. As you call <c>Write()</c> on the <c>GZipStream</c>, the
               data will be compressed into the GZIP format.  If you want to decompress data,
               you must wrap the <c>GZipStream</c> around a readable stream that contains an
               IETF RFC 1952-compliant stream.  The data will be decompressed as you call
               <c>Read()</c> on the <c>GZipStream</c>.
             </para>
            
             <para>
               Though the GZIP format allows data from multiple files to be concatenated
               together, this stream handles only a single segment of GZIP format, typically
               representing a single file.
             </para>
            
             <para>
               This class is similar to <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream"/> and <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/>.
               <c>ZlibStream</c> handles RFC1950-compliant streams.  <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/>
               handles RFC1951-compliant streams. This class handles RFC1952-compliant streams.
             </para>
            
             </remarks>
            
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream" />
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream" />
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Comment">
             <summary>
               The comment on the GZIP stream.
             </summary>
            
             <remarks>
             <para>
               The GZIP format allows for each file to optionally have an associated
               comment stored with the file.  The comment is encoded with the ISO-8859-1
               code page.  To include a comment in a GZIP stream you create, set this
               property before calling <c>Write()</c> for the first time on the
               <c>GZipStream</c>.
             </para>
            
             <para>
               When using <c>GZipStream</c> to decompress, you can retrieve this property
               after the first call to <c>Read()</c>.  If no comment has been set in the
               GZIP bytestream, the Comment property will return <c>null</c>
               (<c>Nothing</c> in VB).
             </para>
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.FileName">
             <summary>
               The FileName for the GZIP stream.
             </summary>
            
             <remarks>
            
             <para>
               The GZIP format optionally allows each file to have an associated
               filename.  When compressing data (through <c>Write()</c>), set this
               FileName before calling <c>Write()</c> the first time on the <c>GZipStream</c>.
               The actual filename is encoded into the GZIP bytestream with the
               ISO-8859-1 code page, according to RFC 1952. It is the application's
               responsibility to insure that the FileName can be encoded and decoded
               correctly with this code page.
             </para>
            
             <para>
               When decompressing (through <c>Read()</c>), you can retrieve this value
               any time after the first <c>Read()</c>.  In the case where there was no filename
               encoded into the GZIP bytestream, the property will return <c>null</c> (<c>Nothing</c>
               in VB).
             </para>
             </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.LastModified">
             <summary>
               The last modified time for the GZIP stream.
             </summary>
            
             <remarks>
               GZIP allows the storage of a last modified time with each GZIP entry.
               When compressing data, you can set this before the first call to
               <c>Write()</c>.  When decompressing, you can retrieve this value any time
               after the first call to <c>Read()</c>.
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Crc32">
            <summary>
            The CRC on the GZIP stream.
            </summary>
            <remarks>
            This is used for internal error checking. You probably don't need to look at this property.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>GZipStream</c> will use the
               default compression level.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with
               <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a GZipStream to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <example>
             This example shows how to use a GZipStream to uncompress a file.
             <code>
             private void GunZipFile(string filename)
             {
                 if (!filename.EndsWith(".gz))
                     throw new ArgumentException("filename");
                 var DecompressedFile = filename.Substring(0,filename.Length-3);
                 byte[] working = new byte[WORKING_BUFFER_SIZE];
                 int n= 1;
                 using (System.IO.Stream input = System.IO.File.OpenRead(filename))
                 {
                     using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                     {
                         using (var output = System.IO.File.Create(DecompressedFile))
                         {
                             while (n !=0)
                             {
                                 n= decompressor.Read(working, 0, working.Length);
                                 if (n > 0)
                                 {
                                     output.Write(working, 0, n);
                                 }
                             }
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Private Sub GunZipFile(ByVal filename as String)
                 If Not (filename.EndsWith(".gz)) Then
                     Throw New ArgumentException("filename")
                 End If
                 Dim DecompressedFile as String = filename.Substring(0,filename.Length-3)
                 Dim working(WORKING_BUFFER_SIZE) as Byte
                 Dim n As Integer = 1
                 Using input As Stream = File.OpenRead(filename)
                     Using decompressor As Stream = new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, True)
                         Using output As Stream = File.Create(UncompressedFile)
                             Do
                                 n= decompressor.Read(working, 0, working.Length)
                                 If n > 0 Then
                                     output.Write(working, 0, n)
                                 End IF
                             Loop While (n  > 0)
                         End Using
                     End Using
                 End Using
             End Sub
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
             <remarks>
            
             <para>
               The <c>CompressionMode</c> (Compress or Decompress) also establishes the
               "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A
               <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a <c>GZipStream</c> to compress a file into a .gz file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".gz"))
                 {
                     using (Stream compressor = new GZipStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".gz")
                     Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the <c>GZipStream</c> will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the stream should be left open after Deflation
               or Inflation.
             </summary>
            
             <remarks>
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to leave
               the stream open.
             </para>
            
             <para>
               The <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode"/> (Compress or Decompress) also
               establishes the "direction" of the stream.  A <c>GZipStream</c> with
               <c>CompressionMode.Compress</c> works only through <c>Write()</c>.  A <c>GZipStream</c>
               with <c>CompressionMode.Decompress</c> works only through <c>Read()</c>.
             </para>
            
             <para>
               The <c>GZipStream</c> will use the default compression level. If you want
               to specify the compression level, see <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Boolean)"/>.
             </para>
            
             <para>
               See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">
               The stream which will be read or written. This is called the "captive"
               stream in other places in this documentation.
             </param>
            
             <param name="mode">Indicates whether the GZipStream will compress or decompress.
             </param>
            
             <param name="leaveOpen">
               true if the application would like the base stream to remain open after
               inflation/deflation.
             </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>GZipStream</c> using the specified <c>CompressionMode</c> and the
               specified <c>CompressionLevel</c>, and explicitly specify whether the
               stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               memory stream that will be re-read after compressed data has been written
               to it.  Specify true for the <paramref name="leaveOpen"/> parameter to
               leave the stream open.
             </para>
            
             <para>
               As noted in the class documentation, the <c>CompressionMode</c> (Compress
               or Decompress) also establishes the "direction" of the stream.  A
               <c>GZipStream</c> with <c>CompressionMode.Compress</c> works only through
               <c>Write()</c>.  A <c>GZipStream</c> with <c>CompressionMode.Decompress</c> works only
               through <c>Read()</c>.
             </para>
            
             </remarks>
            
             <example>
               This example shows how to use a <c>GZipStream</c> to compress data.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                 Using compressor As Stream = New GZipStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the GZipStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes.  The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotImplementedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Read and decompress data from the source stream.
             </summary>
            
             <remarks>
               With a <c>GZipStream</c>, decompression is done through reading.
             </remarks>
            
             <example>
             <code>
             byte[] working = new byte[WORKING_BUFFER_SIZE];
             using (System.IO.Stream input = System.IO.File.OpenRead(_CompressedFile))
             {
                 using (Stream decompressor= new Ionic.Zlib.GZipStream(input, CompressionMode.Decompress, true))
                 {
                     using (var output = System.IO.File.Create(_DecompressedFile))
                     {
                         int n;
                         while ((n= decompressor.Read(working, 0, working.Length)) !=0)
                         {
                             output.Write(working, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
             <param name="buffer">The buffer into which the decompressed data should be placed.</param>
             <param name="offset">the offset within that data array to put the first byte read.</param>
             <param name="count">the number of bytes to read.</param>
             <returns>the number of bytes actually read</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="offset">irrelevant; it will always throw!</param>
            <param name="origin">irrelevant; it will always throw!</param>
            <returns>irrelevant!</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.SetLength(System.Int64)">
            <summary>
              Calling this method always throws a <see cref="T:System.NotImplementedException"/>.
            </summary>
            <param name="value">irrelevant; this method will always throw!</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
             <para>
               If you wish to use the <c>GZipStream</c> to compress data while writing,
               you can create a <c>GZipStream</c> with <c>CompressionMode.Compress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that <c>GZipStream</c>,
               providing uncompressed data as input.  The data sent to the output stream
               will be the compressed form of the data written.
             </para>
            
             <para>
               A <c>GZipStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not
               both. Writing implies compression.  Reading implies decompression.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
            
             <param name="s">
               A string to compress. The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using GZip.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
               A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a single string.
             </summary>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressString(System.String)"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing GZIP-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a GZip'ed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing data that has been compressed with GZip.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream">
             <summary>
               A class for compressing streams using the
               Deflate algorithm with multiple threads.
             </summary>
            
             <remarks>
             <para>
               This class performs DEFLATE compression through writing.  For
               more information on the Deflate algorithm, see IETF RFC 1951,
               "DEFLATE Compressed Data Format Specification version 1.3."
             </para>
            
             <para>
               This class is similar to <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/>, except
               that this class is for compression only, and this implementation uses an
               approach that employs multiple worker threads to perform the DEFLATE.  On
               a multi-cpu or multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream, particularly
               for larger streams.  How large?  Anything over 10mb is a good candidate
               for parallel compression.
             </para>
            
             <para>
               The tradeoff is that this class uses more memory and more CPU than the
               vanilla DeflateStream, and also is less efficient as a compressor. For
               large files the size of the compressed data stream can be less than 1%
               larger than the size of a compressed data stream from the vanialla
               DeflateStream.  For smaller files the difference can be larger.  The
               difference will also be larger if you set the BufferSize to be lower than
               the default value.  Your mileage may vary. Finally, for small files, the
               ParallelDeflateOutputStream can be much slower than the vanilla
               DeflateStream, because of the overhead associated to using the thread
               pool.
             </para>
            
             </remarks>
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream" />
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)">
             <summary>
             Create a ParallelDeflateOutputStream.
             </summary>
             <remarks>
            
             <para>
               This stream compresses data written into it via the DEFLATE
               algorithm (see RFC 1951), and writes out the compressed byte stream.
             </para>
            
             <para>
               The instance will use the default compression level, the default
               buffer sizes and the default number of threads and buffers per
               thread.
             </para>
            
             <para>
               This class is similar to <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/>,
               except that this implementation uses an approach that employs
               multiple worker threads to perform the DEFLATE.  On a multi-cpu or
               multi-core computer, the performance of this class can be
               significantly higher than the single-threaded DeflateStream,
               particularly for larger streams.  How large?  Anything over 10mb is
               a good candidate for parallel compression.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ParallelDeflateOutputStream to compress
             data.  It reads a file, compresses it, and writes the compressed data to
             a second, output file.
            
             <code>
             byte[] buffer = new byte[WORKING_BUFFER_SIZE];
             int n= -1;
             String outputFile = fileToCompress + ".compressed";
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(outputFile))
                 {
                     using (Stream compressor = new ParallelDeflateOutputStream(raw))
                     {
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Dim buffer As Byte() = New Byte(4096) {}
             Dim n As Integer = -1
             Dim outputFile As String = (fileToCompress &amp; ".compressed")
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(outputFile)
                     Using compressor As Stream = New ParallelDeflateOutputStream(raw)
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
             <param name="stream">The stream to which compressed data will be written.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel)">
            <summary>
              Create a ParallelDeflateOutputStream using the specified CompressionLevel.
            </summary>
            <remarks>
              See the <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream and specify whether to leave the captive stream open
            when the ParallelDeflateOutputStream is closed.
            </summary>
            <remarks>
              See the <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionStrategy,System.Boolean)">
            <summary>
            Create a ParallelDeflateOutputStream using the specified
            CompressionLevel and CompressionStrategy, and specifying whether to
            leave the captive stream open when the ParallelDeflateOutputStream is
            closed.
            </summary>
            <remarks>
              See the <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.#ctor(System.IO.Stream)"/>
              constructor for example code.
            </remarks>
            <param name="stream">The stream to which compressed data will be written.</param>
            <param name="level">A tuning knob to trade speed for effectiveness.</param>
            <param name="strategy">
              By tweaking this parameter, you may be able to optimize the compression for
              data with particular characteristics.
            </param>
            <param name="leaveOpen">
               true if the application would like the stream to remain open after inflation/deflation.
            </param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Strategy">
             <summary>
               The ZLIB strategy to be used during compression.
             </summary>
            
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.MaxBufferPairs">
             <summary>
               The maximum number of buffer pairs to use.
             </summary>
            
             <remarks>
             <para>
               This property sets an upper limit on the number of memory buffer
               pairs to create.  The implementation of this stream allocates
               multiple buffers to facilitate parallel compression.  As each buffer
               fills up, this stream uses <see
               cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
               ThreadPool.QueueUserWorkItem()</see>
               to compress those buffers in a background threadpool thread. After a
               buffer is compressed, it is re-ordered and written to the output
               stream.
             </para>
            
             <para>
               A higher number of buffer pairs enables a higher degree of
               parallelism, which tends to increase the speed of compression on
               multi-cpu computers.  On the other hand, a higher number of buffer
               pairs also implies a larger memory consumption, more active worker
               threads, and a higher cpu utilization for any compression. This
               property enables the application to limit its memory consumption and
               CPU utilization behavior depending on requirements.
             </para>
            
             <para>
               For each compression "task" that occurs in parallel, there are 2
               buffers allocated: one for input and one for output.  This property
               sets a limit for the number of pairs.  The total amount of storage
               space allocated for buffering will then be (N*S*2), where N is the
               number of buffer pairs, S is the size of each buffer (<see
               cref="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.BufferSize"/>).  By default, DotNetZip allocates 4 buffer
               pairs per CPU core, so if your machine has 4 cores, and you retain
               the default buffer size of 128k, then the
               ParallelDeflateOutputStream will use 4 * 4 * 2 * 128kb of buffer
               memory in total, or 4mb, in blocks of 128kb.  If you then set this
               property to 8, then the number will be 8 * 2 * 128kb of buffer
               memory, or 2mb.
             </para>
            
             <para>
               CPU utilization will also go up with additional buffers, because a
               larger number of buffer pairs allows a larger number of background
               threads to compress in parallel. If you find that parallel
               compression is consuming too much memory or CPU, you can adjust this
               value downward.
             </para>
            
             <para>
               The default value is 16. Different values may deliver better or
               worse results, depending on your priorities and the dynamic
               performance characteristics of your storage and compute resources.
             </para>
            
             <para>
               This property is not the number of buffer pairs to use; it is an
               upper limit. An illustration: Suppose you have an application that
               uses the default value of this property (which is 16), and it runs
               on a machine with 2 CPU cores. In that case, DotNetZip will allocate
               4 buffer pairs per CPU core, for a total of 8 pairs.  The upper
               limit specified by this property has no effect.
             </para>
            
             <para>
               The application can set this value at any time, but it is effective
               only before the first call to Write(), which is when the buffers are
               allocated.
             </para>
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.BufferSize">
             <summary>
               The size of the buffers used by the compressor threads.
             </summary>
             <remarks>
            
             <para>
               The default buffer size is 128k. The application can set this value
               at any time, but it is effective only before the first Write().
             </para>
            
             <para>
               Larger buffer sizes implies larger memory consumption but allows
               more efficient compression. Using smaller buffer sizes consumes less
               memory but may result in less effective compression.  For example,
               using the default buffer size of 128k, the compression delivered is
               within 1% of the compression delivered by the single-threaded <see
               cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/>.  On the other hand, using a
               BufferSize of 8k can result in a compressed data stream that is 5%
               larger than that delivered by the single-threaded
               <c>DeflateStream</c>.  Excessively small buffer sizes can also cause
               the speed of the ParallelDeflateOutputStream to drop, because of
               larger thread scheduling overhead dealing with many many small
               buffers.
             </para>
            
             <para>
               The total amount of storage space allocated for buffering will be
               (N*S*2), where N is the number of buffer pairs, and S is the size of
               each buffer (this property). There are 2 buffers used by the
               compressor, one for input and one for output.  By default, DotNetZip
               allocates 4 buffer pairs per CPU core, so if your machine has 4
               cores, then the number of buffer pairs used will be 16. If you
               accept the default value of this property, 128k, then the
               ParallelDeflateOutputStream will use 16 * 2 * 128kb of buffer memory
               in total, or 4mb, in blocks of 128kb.  If you set this property to
               64kb, then the number will be 16 * 2 * 64kb of buffer memory, or
               2mb.
             </para>
            
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Crc32">
            <summary>
            The CRC32 for the data that was written out, prior to compression.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.BytesProcessed">
            <summary>
            The total number of uncompressed bytes processed by the ParallelDeflateOutputStream.
            </summary>
            <remarks>
            This value is meaningful only after a call to Close().
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
               Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               To use the ParallelDeflateOutputStream to compress data, create a
               ParallelDeflateOutputStream with CompressionMode.Compress, passing a
               writable output stream.  Then call Write() on that
               ParallelDeflateOutputStream, providing uncompressed data as input.  The
               data sent to the output stream will be the compressed form of the data
               written.
             </para>
            
             <para>
               To decompress data, use the <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/> class.
             </para>
            
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            You must call Close on the stream to guarantee that all of the data written in has
            been compressed, and the compressed data has been written out.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Dispose">
            <summary>Dispose the object</summary>
            <remarks>
              <para>
                Because ParallelDeflateOutputStream is IDisposable, the
                application must call this method when finished using the instance.
              </para>
              <para>
                This method is generally called implicitly upon exit from
                a <c>using</c> scope in C# (<c>Using</c> in VB).
              </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Dispose(System.Boolean)">
            <summary>The Dispose method</summary>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Reset(System.IO.Stream)">
             <summary>
               Resets the stream for use with another stream.
             </summary>
             <remarks>
               Because the ParallelDeflateOutputStream is expensive to create, it
               has been designed so that it can be recycled and re-used.  You have
               to call Close() on the stream first, then you can call Reset() on
               it, to use it again on another stream.
             </remarks>
            
             <param name="stream">
               The new output stream for this era.
             </param>
            
             <example>
             <code>
             ParallelDeflateOutputStream deflater = null;
             foreach (var inputFile in listOfFiles)
             {
                 string outputFile = inputFile + ".compressed";
                 using (System.IO.Stream input = System.IO.File.OpenRead(inputFile))
                 {
                     using (var outStream = System.IO.File.Create(outputFile))
                     {
                         if (deflater is null)
                             deflater = new ParallelDeflateOutputStream(outStream,
                                                                        CompressionLevel.Best,
                                                                        CompressionStrategy.Default,
                                                                        true);
                         deflater.Reset(outStream);
            
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             deflater.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.CanRead">
            <summary>
            Indicates whether the stream supports Read operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.CanWrite">
            <summary>
            Indicates whether the stream supports Write operations.
            </summary>
            <remarks>
            Returns true if the provided stream is writable.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Length">
            <summary>
            Reading this property always throws a NotSupportedException.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Position">
            <summary>
            Returns the current position of the output stream.
            </summary>
            <remarks>
              <para>
                Because the output gets written by a background thread,
                the value may change asynchronously.  Setting this
                property always throws a NotSupportedException.
              </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="buffer">
              The buffer into which data would be read, IF THIS METHOD
              ACTUALLY DID ANYTHING.
            </param>
            <param name="offset">
              The offset within that data array at which to insert the
              data that is read, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <param name="count">
              The number of bytes to write, IF THIS METHOD ACTUALLY DID
              ANYTHING.
            </param>
            <returns>nothing.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="offset">
              The offset to seek to....
              IF THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <param name="origin">
              The reference specifying how to apply the offset....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
            <returns>nothing. It always throws.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ParallelDeflateOutputStream.SetLength(System.Int64)">
            <summary>
            This method always throws a NotSupportedException.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.Tree.DistanceCode(System.Int32)">
            <summary>
            Map from a distance to a distance code.
            </summary>
            <remarks> 
            No side effects. _dist_code[256] and _dist_code[257] are never used.
            </remarks>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType">
            <summary>
            Describes how to flush the current deflate operation.
            </summary>
            <remarks>
            The different FlushType values are useful when using a Deflate in a streaming application.
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType.None">
            <summary>No flush at all.</summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType.Partial">
            <summary>Closes the current block, but doesn't flush it to
            the output. Used internally only in hypothetical
            scenarios.  This was supposed to be removed by Zlib, but it is
            still in use in some edge cases.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType.Sync">
            <summary>
            Use this during compression to specify that all pending output should be
            flushed to the output buffer and the output should be aligned on a byte
            boundary.  You might use this in a streaming communication scenario, so that
            the decompressor can get all input data available so far.  When using this
            with a ZlibCodec, <c>AvailableBytesIn</c> will be zero after the call if
            enough output space has been provided before the call.  Flushing will
            degrade compression and so it should be used only when necessary.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType.Full">
            <summary>
            Use this during compression to specify that all output should be flushed, as
            with <c>FlushType.Sync</c>, but also, the compression state should be reset
            so that decompression can restart from this point if previous compressed
            data has been damaged or if random access is desired.  Using
            <c>FlushType.Full</c> too often can significantly degrade the compression.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType.Finish">
            <summary>Signals the end of the compression/decompression stream.</summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel">
            <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.None">
            <summary>
            None means that the data will be simply stored, with no change at all.
            If you are producing ZIPs for use on Mac OSX, be aware that archives produced with CompressionLevel.None
            cannot be opened with the default zip reader. Use a different CompressionLevel.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level0">
            <summary>
            Same as None.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.BestSpeed">
            <summary>
            The fastest but least effective compression.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level1">
            <summary>
            A synonym for BestSpeed.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level2">
            <summary>
            A little slower, but better, than level 1.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level3">
            <summary>
            A little slower, but better, than level 2.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level4">
            <summary>
            A little slower, but better, than level 3.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level5">
            <summary>
            A little slower than level 4, but with better compression.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Default">
            <summary>
            The default compression level, with a good balance of speed and compression efficiency.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level6">
            <summary>
            A synonym for Default.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level7">
            <summary>
            Pretty good compression!
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level8">
            <summary>
             Better compression than Level7!
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.BestCompression">
            <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream.
            This is also the slowest compression.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel.Level9">
            <summary>
            A synonym for BestCompression.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionStrategy">
            <summary>
            Describes options for how the compression algorithm is executed.  Different strategies
            work better on different sorts of data.  The strategy parameter can affect the compression
            ratio and the speed of compression but not the correctness of the compresssion.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionStrategy.Default">
            <summary>
            The default strategy is probably the best for normal data.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionStrategy.Filtered">
            <summary>
            The <c>Filtered</c> strategy is intended to be used most effectively with data produced by a
            filter or predictor.  By this definition, filtered data consists mostly of small
            values with a somewhat random distribution.  In this case, the compression algorithm
            is tuned to compress them better.  The effect of <c>Filtered</c> is to force more Huffman
            coding and less string matching; it is a half-step between <c>Default</c> and <c>HuffmanOnly</c>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionStrategy.HuffmanOnly">
            <summary>
            Using <c>HuffmanOnly</c> will force the compressor to do Huffman encoding only, with no
            string matching.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode">
            <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode.Compress">
            <summary>
            Used to specify that the stream should compress the data.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode.Decompress">
            <summary>
            Used to specify that the stream should decompress the data.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibException">
            <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibException.#ctor">
            <summary>
            The ZlibException class captures exception information generated
            by the Zlib library.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibException.#ctor(System.String)">
            <summary>
            This ctor collects a message attached to the exception.
            </summary>
            <param name="s">the message for the exception.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
             <summary>
               Reads a number of characters from the current source TextReader and writes
               the data to the target array at the specified index.
             </summary>
            
             <param name="sourceTextReader">The source TextReader to read from</param>
             <param name="target">Contains the array of characteres read from the source TextReader.</param>
             <param name="start">The starting index of the target array.</param>
             <param name="count">The maximum number of characters to read from the source TextReader.</param>
            
             <returns>
               The number of characters read. The number will be less than or equal to
               count depending on the data available in the source TextReader. Returns -1
               if the end of the stream is reached.
             </returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.Adler">
             <summary>
             Computes an Adler-32 checksum.
             </summary>
             <remarks>
             The Adler checksum is similar to a CRC checksum, but faster to compute, though less
             reliable.  It is used in producing RFC1950 compressed streams.  The Adler checksum
             is a required part of the "ZLIB" standard.  Applications will almost never need to
             use this class directly.
             </remarks>
            
             <exclude/>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.Adler.Adler32(System.UInt32,System.Byte[],System.Int32,System.Int32)">
            <summary>
              Calculates the Adler32 checksum.
            </summary>
            <remarks>
              <para>
                This is used within ZLIB.  You probably don't need to use this directly.
              </para>
            </remarks>
            <example>
               To compute an Adler32 checksum on a byte array:
             <code>
               var adler = Adler.Adler32(0, null, 0, 0);
               adler = Adler.Adler32(adler, buffer, index, length);
             </code>
            </example>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec">
             <summary>
             Encoder and Decoder for ZLIB and DEFLATE (IETF RFC1950 and RFC1951).
             </summary>
            
             <remarks>
             This class compresses and decompresses data according to the Deflate algorithm
             and optionally, the ZLIB format, as documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950 - ZLIB</see> and <see
             href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951 - DEFLATE</see>.
             </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InputBuffer">
            <summary>
            The buffer from which data is taken.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.NextIn">
            <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.AvailableBytesIn">
            <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
            <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.TotalBytesIn">
            <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.OutputBuffer">
            <summary>
            Buffer to store output data.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.NextOut">
            <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.AvailableBytesOut">
            <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
            <remarks>
            Generally you should set this to OutputBuffer!.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.TotalBytesOut">
            <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.Message">
            <summary>
            used for diagnostics, when something goes wrong!
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.CompressLevel">
            <summary>
            The compression level to use in this codec.  Useful only in compression mode.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.WindowBits">
            <summary>
            The number of Window Bits to use.  
            </summary>
            <remarks>
            This gauges the size of the sliding window, and hence the 
            compression effectiveness as well as memory consumption. It's best to just leave this 
            setting alone if you don't know what it is.  The maximum value is 15 bits, which implies
            a 32k window.  
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.Strategy">
            <summary>
            The compression strategy to use.
            </summary>
            <remarks>
            This is only effective in compression.  The theory offered by ZLIB is that different
            strategies could potentially produce significant differences in compression behavior
            for different data sets.  Unfortunately I don't have any good recommendations for how
            to set it differently.  When I tested changing the strategy I got minimally different
            compression performance. It's best to leave this property alone if you don't have a
            good feel for it.  Or, you may want to produce a test harness that runs through the
            different strategy options and evaluates them on different file types. If you do that,
            let me know your results.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.Adler32">
            <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.#ctor">
            <summary>
            Create a ZlibCodec.
            </summary>
            <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.#ctor(Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode)">
            <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
            <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeInflate">
            <summary>
            Initialize the inflation state. 
            </summary>
            <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to
             govern the handling of RFC1950 header bytes.
             </summary>
            
             <remarks>
             By default, the ZLIB header defined in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</see> is expected.  If
             you want to read a zlib stream you should specify true for
             expectRfc1950Header.  If you have a deflate stream, you will want to specify
             false. It is only necessary to invoke this initializer explicitly if you
             want to specify false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte
             pair when reading the stream of data to be inflated.</param>
            
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
            <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
            <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
             <summary>
             Initialize the inflation state with an explicit flag to govern the handling of
             RFC1950 header bytes. 
             </summary>
            
             <remarks>
             If you want to read a zlib stream you should specify true for
             expectRfc1950Header. In this case, the library will expect to find a ZLIB
             header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
             1950</see>, in the compressed stream.  If you will be reading a DEFLATE or
             GZIP stream, which does not have such a header, you will want to specify
             false.
             </remarks>
            
             <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
             the stream of data to be inflated.</param>
             <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
             then you shouldn't be calling this initializer.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.Inflate(Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType)">
             <summary>
             Inflate the data in the InputBuffer, placing the result in the OutputBuffer!.
             </summary>
             <remarks>
             You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
             AvailableBytesOut  before calling this method.
             </remarks>
             <example>
             <code>
             private void InflateBuffer()
             {
                 int bufferSize = 1024;
                 byte[] buffer = new byte[bufferSize];
                 ZlibCodec decompressor = new ZlibCodec();
             
                 Console.WriteLine("\n============================================");
                 Console.WriteLine("Size of Buffer to Inflate: {0} bytes.", CompressedBytes.Length);
                 MemoryStream ms = new MemoryStream(DecompressedBytes);
             
                 int rc = decompressor.InitializeInflate();
             
                 decompressor.InputBuffer = CompressedBytes;
                 decompressor.NextIn = 0;
                 decompressor.AvailableBytesIn = CompressedBytes.Length;
             
                 decompressor.OutputBuffer = buffer;
             
                 // pass 1: inflate 
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.None);
             
                     if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     ms.Write(decompressor.OutputBuffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 // pass 2: finish and flush
                 do
                 {
                     decompressor.NextOut = 0;
                     decompressor.AvailableBytesOut = buffer.Length;
                     rc = decompressor.Inflate(FlushType.Finish);
             
                     if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                         throw new Exception("inflating: " + decompressor.Message);
             
                     if (buffer.Length - decompressor.AvailableBytesOut &gt; 0)
                         ms.Write(buffer, 0, buffer.Length - decompressor.AvailableBytesOut);
                 }
                 while (decompressor.AvailableBytesIn &gt; 0 || decompressor.AvailableBytesOut == 0);
             
                 decompressor.EndInflate();
             }
            
             </code>
             </example>
             <param name="flush">The flush to use when inflating.</param>
             <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.EndInflate">
            <summary>
            Ends an inflation session. 
            </summary>
            <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.SyncInflate">
            <summary>
            I don't know what this does!
            </summary>
            <returns>Z_OK if everything goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeDeflate">
            <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
            <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
            <example>
            <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.Default);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(FlushType.None);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(FlushType.Finish);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
            </example>
            <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeDeflate(Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified
            CompressionLevel.  It will emit a ZLIB stream as it compresses.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeDeflate(Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Boolean)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
            <remarks>
            The codec will use the maximum window bits (15) and the specified CompressionLevel.
            If you want to generate a zlib stream, you should specify true for
            wantRfc1950Header. In this case, the library will emit a ZLIB
            header, as defined in <see href="http://www.ietf.org/rfc/rfc1950.txt">RFC
            1950</see>, in the compressed stream.  
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeDeflate(Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Int32)">
            <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
            <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
            <param name="level">The compression level for the codec.</param>
            <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.InitializeDeflate(Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
             <summary>
             Initialize the ZlibCodec for deflation operation, using the specified
             CompressionLevel, the specified number of window bits, and the explicit flag
             governing whether to emit an RFC1950 header byte pair.
             </summary>
            
             <param name="level">The compression level for the codec.</param>
             <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
             <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
             <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.Deflate(Gemstone.Diagnostics.Internal.Ionic.Zlib.FlushType)">
            <summary>
            Deflate one batch of data.
            </summary>
            <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
            <example>
            <code>
            private void DeflateBuffer(CompressionLevel level)
            {
                int bufferSize = 1024;
                byte[] buffer = new byte[bufferSize];
                ZlibCodec compressor = new ZlibCodec();
            
                Console.WriteLine("\n============================================");
                Console.WriteLine("Size of Buffer to Deflate: {0} bytes.", UncompressedBytes.Length);
                MemoryStream ms = new MemoryStream();
            
                int rc = compressor.InitializeDeflate(level);
            
                compressor.InputBuffer = UncompressedBytes;
                compressor.NextIn = 0;
                compressor.AvailableBytesIn = UncompressedBytes.Length;
            
                compressor.OutputBuffer = buffer;
            
                // pass 1: deflate 
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.None);
            
                    if (rc != ZlibConstants.Z_OK &amp;&amp; rc != ZlibConstants.Z_STREAM_END)
                        throw new Exception("deflating: " + compressor.Message);
            
                    ms.Write(compressor.OutputBuffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                // pass 2: finish and flush
                do
                {
                    compressor.NextOut = 0;
                    compressor.AvailableBytesOut = buffer.Length;
                    rc = compressor.Deflate(FlushType.Finish);
            
                    if (rc != ZlibConstants.Z_STREAM_END &amp;&amp; rc != ZlibConstants.Z_OK)
                        throw new Exception("deflating: " + compressor.Message);
            
                    if (buffer.Length - compressor.AvailableBytesOut &gt; 0)
                        ms.Write(buffer, 0, buffer.Length - compressor.AvailableBytesOut);
                }
                while (compressor.AvailableBytesIn &gt; 0 || compressor.AvailableBytesOut == 0);
            
                compressor.EndDeflate();
            
                ms.Seek(0, SeekOrigin.Begin);
                CompressedBytes = new byte[compressor.TotalBytesOut];
                ms.Read(CompressedBytes, 0, CompressedBytes.Length);
            }
            </code>
            </example>
            <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.EndDeflate">
            <summary>
            End a deflation session.
            </summary>
            <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.ResetDeflate">
            <summary>
            Reset a codec for another deflation session.
            </summary>
            <remarks>
            Call this to reset the deflation state.  For example if a thread is deflating
            non-consecutive blocks, you can call Reset() after the Deflate(Sync) of the first
            block and before the next Deflate(None) of the second block.
            </remarks>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.SetDeflateParams(Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionStrategy)">
            <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
            <param name="level">the level of compression to use.</param>
            <param name="strategy">the strategy to use for compression.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
            <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
            <param name="dictionary">The dictionary bytes to use.</param>
            <returns>Z_OK if all goes well.</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants">
            <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.WindowBitsMax">
            <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.WindowBitsDefault">
            <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.Z_OK">
            <summary>
            indicates everything is A-OK
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.Z_STREAM_END">
            <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
            <summary>
            The operation ended in need of a dictionary. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
            <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
            <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
            <summary>
            There was an error with the working buffer.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.WorkingBufferSizeDefault">
            <summary>
            The size of the working buffer used in the ZlibCodec class. Defaults to 8192 bytes.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibConstants.WorkingBufferSizeMin">
            <summary>
            The minimum size of the working buffer used in the ZlibCodec class.  Currently it is 128 bytes.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream">
             <summary>
             Represents a Zlib stream for compression or decompression.
             </summary>
             <remarks>
            
             <para>
             The ZlibStream is a <see
             href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</see> on a <see
             cref="T:System.IO.Stream"/>.  It adds ZLIB compression or decompression to any
             stream.
             </para>
            
             <para> Using this stream, applications can compress or decompress data via
             stream <c>Read()</c> and <c>Write()</c> operations.  Either compresssion or
             decompression can occur through either reading or writing. The compression
             format used is ZLIB, which is documented in <see
             href="http://www.ietf.org/rfc/rfc1950.txt">IETF RFC 1950</see>, "ZLIB Compressed
             Data Format Specification version 3.3". This implementation of ZLIB always uses
             DEFLATE as the compression method.  (see <see
             href="http://www.ietf.org/rfc/rfc1951.txt">IETF RFC 1951</see>, "DEFLATE
             Compressed Data Format Specification version 1.3.") </para>
            
             <para>
             The ZLIB format allows for varying compression methods, window sizes, and dictionaries.
             This implementation always uses the DEFLATE compression method, a preset dictionary,
             and 15 window bits by default.
             </para>
            
             <para>
             This class is similar to <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream"/>, except that it adds the
             RFC1950 header and trailer bytes to a compressed stream when compressing, or expects
             the RFC1950 header and trailer bytes when decompressing.  It is also similar to the
             <see cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream"/>.
             </para>
             </remarks>
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.DeflateStream" />
             <seealso cref="T:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream" />
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode)">
             <summary>
             Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>.
             </summary>
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c>
               will use the default compression level. The "captive" stream will be
               closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
             This example uses a <c>ZlibStream</c> to compress a file, and writes the
             compressed data to another file.
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw, CompressionMode.Compress))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress)
                     Dim buffer As Byte() = New Byte(4096) {}
                     Dim n As Integer = -1
                     Do While (n &lt;&gt; 0)
                         If (n &gt; 0) Then
                             compressor.Write(buffer, 0, n)
                         End If
                         n = input.Read(buffer, 0, buffer.Length)
                     Loop
                 End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c> and
               the specified <c>CompressionLevel</c>.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is ignored.
               The "captive" stream will be closed when the <c>ZlibStream</c> is closed.
             </para>
            
             </remarks>
            
             <example>
               This example uses a <c>ZlibStream</c> to compress data from a file, and writes the
               compressed data to another file.
            
             <code>
             using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
             {
                 using (var raw = System.IO.File.Create(fileToCompress + ".zlib"))
                 {
                     using (Stream compressor = new ZlibStream(raw,
                                                               CompressionMode.Compress,
                                                               CompressionLevel.BestCompression))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
             }
             </code>
            
             <code lang="VB">
             Using input As Stream = File.OpenRead(fileToCompress)
                 Using raw As FileStream = File.Create(fileToCompress &amp; ".zlib")
                     Using compressor As Stream = New ZlibStream(raw, CompressionMode.Compress, CompressionLevel.BestCompression)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
             End Using
             </code>
             </example>
            
             <param name="stream">The stream to be read or written while deflating or inflating.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="level">A tuning knob to trade speed for effectiveness.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>, and
               explicitly specify whether the captive stream should be left open after
               Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               When mode is <c>CompressionMode.Compress</c>, the <c>ZlibStream</c> will use
               the default compression level.
             </para>
            
             <para>
               This constructor allows the application to request that the captive stream
               remain open after the deflation or inflation occurs.  By default, after
               <c>Close()</c> is called on the stream, the captive stream is also
               closed. In some cases this is not desired, for example if the stream is a
               <see cref="T:System.IO.MemoryStream"/> that will be re-read after
               compression.  Specify true for the <paramref name="leaveOpen"/> parameter to leave the stream
               open.
             </para>
            
             <para>
             See the other overloads of this constructor for example code.
             </para>
            
             </remarks>
            
             <param name="stream">The stream which will be read or written. This is called the
             "captive" stream in other places in this documentation.</param>
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
             <param name="leaveOpen">true if the application would like the stream to remain
             open after inflation/deflation.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionMode,Gemstone.Diagnostics.Internal.Ionic.Zlib.CompressionLevel,System.Boolean)">
             <summary>
               Create a <c>ZlibStream</c> using the specified <c>CompressionMode</c>
               and the specified <c>CompressionLevel</c>, and explicitly specify
               whether the stream should be left open after Deflation or Inflation.
             </summary>
            
             <remarks>
            
             <para>
               This constructor allows the application to request that the captive
               stream remain open after the deflation or inflation occurs.  By
               default, after <c>Close()</c> is called on the stream, the captive
               stream is also closed. In some cases this is not desired, for example
               if the stream is a <see cref="T:System.IO.MemoryStream"/> that will be
               re-read after compression.  Specify true for the <paramref
               name="leaveOpen"/> parameter to leave the stream open.
             </para>
            
             <para>
               When mode is <c>CompressionMode.Decompress</c>, the level parameter is
               ignored.
             </para>
            
             </remarks>
            
             <example>
            
             This example shows how to use a ZlibStream to compress the data from a file,
             and store the result into another file. The filestream remains open to allow
             additional data to be written to it.
            
             <code>
             using (var output = System.IO.File.Create(fileToCompress + ".zlib"))
             {
                 using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
                 {
                     using (Stream compressor = new ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, true))
                     {
                         byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                         int n;
                         while ((n= input.Read(buffer, 0, buffer.Length)) != 0)
                         {
                             compressor.Write(buffer, 0, n);
                         }
                     }
                 }
                 // can write additional data to the output stream here
             }
             </code>
             <code lang="VB">
             Using output As FileStream = File.Create(fileToCompress &amp; ".zlib")
                 Using input As Stream = File.OpenRead(fileToCompress)
                     Using compressor As Stream = New ZlibStream(output, CompressionMode.Compress, CompressionLevel.BestCompression, True)
                         Dim buffer As Byte() = New Byte(4096) {}
                         Dim n As Integer = -1
                         Do While (n &lt;&gt; 0)
                             If (n &gt; 0) Then
                                 compressor.Write(buffer, 0, n)
                             End If
                             n = input.Read(buffer, 0, buffer.Length)
                         Loop
                     End Using
                 End Using
                 ' can write additional data to the output stream here.
             End Using
             </code>
             </example>
            
             <param name="stream">The stream which will be read or written.</param>
            
             <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
            
             <param name="leaveOpen">
             true if the application would like the stream to remain open after
             inflation/deflation.
             </param>
            
             <param name="level">
             A tuning knob to trade speed for effectiveness. This parameter is
             effective only when mode is <c>CompressionMode.Compress</c>.
             </param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.FlushMode">
            <summary>
            This property sets the flush behavior on the stream.
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.BufferSize">
             <summary>
               The size of the working buffer for the compression codec.
             </summary>
            
             <remarks>
             <para>
               The working buffer is used for all stream operations.  The default size is
               1024 bytes. The minimum size is 128 bytes. You may get better performance
               with a larger buffer.  Then again, you might not.  You would have to test
               it.
             </para>
            
             <para>
               Set this before the first call to <c>Read()</c> or <c>Write()</c> on the
               stream. If you try to set it afterwards, it will throw.
             </para>
             </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Dispose(System.Boolean)">
            <summary>
              Dispose the stream.
            </summary>
            <remarks>
              <para>
                This may or may not result in a <c>Close()</c> call on the captive
                stream.  See the constructors that have a <c>leaveOpen</c> parameter
                for more information.
              </para>
              <para>
                This method may be invoked in two distinct scenarios.  If disposing
                == true, the method has been called directly or indirectly by a
                user's code, for example via the public Dispose() method. In this
                case, both managed and unmanaged resources can be referenced and
                disposed.  If disposing == false, the method has been called by the
                runtime from inside the object finalizer and this method should not
                reference other objects; in that case only unmanaged resources must
                be referenced or disposed.
              </para>
            </remarks>
            <param name="disposing">
              indicates whether the Dispose method was invoked by user code.
            </param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CanRead">
            <summary>
            Indicates whether the stream can be read.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CanSeek">
            <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
            <remarks>
            Always returns false.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CanWrite">
            <summary>
            Indicates whether the stream can be written.
            </summary>
            <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Flush">
            <summary>
            Flush the stream.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Length">
            <summary>
            Reading this property always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Position">
             <summary>
               The position of the stream pointer.
             </summary>
            
             <remarks>
               Setting this property always throws a <see
               cref="T:System.NotSupportedException"/>. Reading will return the total bytes
               written out, if used in writing, or the total bytes read in, if used in
               reading.  The count may refer to compressed bytes or uncompressed bytes,
               depending on how you've used the stream.
             </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Read data from the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while reading,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               providing an uncompressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data read will be compressed.  If you wish to
               use the <c>ZlibStream</c> to decompress data while reading, you can create
               a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, providing a
               readable compressed data stream.  Then call <c>Read()</c> on that
               <c>ZlibStream</c>, and the data will be decompressed as it is read.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but
               not both.
             </para>
            
             </remarks>
            
             <param name="buffer">
             The buffer into which the read data should be placed.</param>
            
             <param name="offset">
             the offset within that data array to put the first byte read.</param>
            
             <param name="count">the number of bytes to read.</param>
            
             <returns>the number of bytes read</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
             <summary>
             Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
             </summary>
             <param name="offset">
               The offset to seek to....
               IF THIS METHOD ACTUALLY DID ANYTHING.
             </param>
             <param name="origin">
               The reference specifying how to apply the offset....  IF
               THIS METHOD ACTUALLY DID ANYTHING.
             </param>
            
             <returns>nothing. This method always throws.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
            <summary>
            Calling this method always throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="value">
              The new value for the stream length....  IF
              THIS METHOD ACTUALLY DID ANYTHING.
            </param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
             <summary>
             Write data to the stream.
             </summary>
            
             <remarks>
            
             <para>
               If you wish to use the <c>ZlibStream</c> to compress data while writing,
               you can create a <c>ZlibStream</c> with <c>CompressionMode.Compress</c>,
               and a writable output stream.  Then call <c>Write()</c> on that
               <c>ZlibStream</c>, providing uncompressed data as input.  The data sent to
               the output stream will be the compressed form of the data written.  If you
               wish to use the <c>ZlibStream</c> to decompress data while writing, you
               can create a <c>ZlibStream</c> with <c>CompressionMode.Decompress</c>, and a
               writable output stream.  Then call <c>Write()</c> on that stream,
               providing previously compressed data. The data sent to the output stream
               will be the decompressed form of the data written.
             </para>
            
             <para>
               A <c>ZlibStream</c> can be used for <c>Read()</c> or <c>Write()</c>, but not both.
             </para>
             </remarks>
             <param name="buffer">The buffer holding data to write to the stream.</param>
             <param name="offset">the offset within that data array to find the first byte to write.</param>
             <param name="count">the number of bytes to write.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressString(System.String)">
             <summary>
               Compress a string into a byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.GZipStream.CompressString(System.String)"/>
            
             <param name="s">
               A string to compress.  The string will first be encoded
               using UTF8, then compressed.
             </param>
            
             <returns>The string in compressed form</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])">
             <summary>
               Compress a byte array into a new byte array using ZLIB.
             </summary>
            
             <remarks>
               Uncompress it with <see cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>.
             </remarks>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="b">
             A buffer to compress.
             </param>
            
             <returns>The data in compressed form</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a single string.
             </summary>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressString(System.String)"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The uncompressed string</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressBuffer(System.Byte[])">
             <summary>
               Uncompress a ZLIB-compressed byte array into a byte array.
             </summary>
            
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.CompressBuffer(System.Byte[])"/>
             <seealso cref="M:Gemstone.Diagnostics.Internal.Ionic.Zlib.ZlibStream.UncompressString(System.Byte[])"/>
            
             <param name="compressed">
               A buffer containing ZLIB-compressed data.
             </param>
            
             <returns>The data in uncompressed form</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LogEventPublisherInternal">
            <summary>
            A publisher for a specific event of a <see cref="T:Gemstone.Diagnostics.LogPublisher"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.LogEventPublisherInternal.ShouldRaiseMessageSuppressionNotifications">
            <summary>
            Gets/Sets if a log message should be generated when message suppression occurs.
            Default is true;
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogEventPublisherInternal.#ctor(Gemstone.Diagnostics.Internal.LogMessageAttributes,Gemstone.Diagnostics.LogEventPublisherDetails,Gemstone.Diagnostics.Internal.LogPublisherInternal,Gemstone.Diagnostics.Internal.LoggerInternal,System.Int32,System.Double,System.Int32)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.Internal.LogEventPublisherInternal"/>.
            </summary>
            <param name="attributes"></param>
            <param name="owner">the owner of the log messages.</param>
            <param name="publisher">the publisher that is used to raise messages</param>
            <param name="logger">the callback for all new messages that are generated.</param>
            <param name="stackTraceDepth"></param>
            <param name="messagesPerSecond"></param>
            <param name="burstLimit"></param>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.LogEventPublisherInternal.HasSubscribers">
            <summary>
            Checks if messages generated by this publisher will be received by a subscriber.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Internal.LogEventPublisherInternal.DefaultAttributes">
            <summary>
            The attributes that will be used if not specified.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogEventPublisherInternal.Publish(System.Nullable{Gemstone.Diagnostics.Internal.LogMessageAttributes},System.String,System.String,System.Exception,Gemstone.Diagnostics.LogStackMessages,Gemstone.Diagnostics.LogStackTrace)">
            <summary>
            Raises a log message with the provided data.
            </summary>
            <param name="overriddenAttributes">attributes to use with this message</param>
            <param name="message"></param>
            <param name="details">A long text field with the details of the message.</param>
            <param name="exception">An exception object if one is provided.</param>
            <param name="initialStackMessage"></param>
            <param name="initialStackTrace"></param>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LoggerInternal">
            <summary>
            The fundamental functionality of <see cref="T:Gemstone.Diagnostics.Logger"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.#ctor(Gemstone.Diagnostics.Internal.LoggerInternal@)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.Internal.LoggerInternal"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.CalculateRoutingTable(System.Object,System.EventArgs)">
            <summary>
            Recalculates the entire routing table on a separate thread.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.CalculateRoutingTableForPublisherSync(System.Collections.Generic.List{Gemstone.Diagnostics.Internal.LogSubscriberInternal},Gemstone.Diagnostics.Internal.LogPublisherInternal)">
            <summary>
            This method should be called with a lock on m_syncRoot
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.CreateSubscriber">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.LogSubscriber"/> that can subscribe to log messages.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.RecalculateRoutingTable">
            <summary>
            Invalidates the current routing table.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.OnNewMessage(Gemstone.Diagnostics.LogMessage,Gemstone.Diagnostics.Internal.LogPublisherInternal)">
            <summary>
            Handles the routing of messages through the logging system.
            </summary>
            <param name="message">the message to route</param>
            <param name="publisher">the publisher that is originating this message.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.CreateType(System.Type)">
            <summary>
            Creates a type topic on a specified type.
            </summary>
            <param name="type">the type to create the topic from</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LoggerInternal.Dispose">
            <summary>
            Gracefully terminate all message routing. Function blocks until all termination is successful.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LogMessageAttributes">
            <summary>
            All of the attributes that can be assigned to a <see cref="T:Gemstone.Diagnostics.LogMessage"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LogMessageSaveHelper">
            <summary>
            Assists in the saving of a LogMessage. This class is here to help de-duplicate classes so they don't take so much 
            space or memory.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LogPublisherInternal">
            <summary>
            This publisher is shared by all other instances of the same <see cref="F:Gemstone.Diagnostics.Internal.LogPublisherInternal.Type"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.LogPublisherInternal.m_logger">
            <summary>
            Occurs when a new <see cref="T:Gemstone.Diagnostics.LogMessage"/> is ready to be published.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogPublisherInternal.HasSubscribers(Gemstone.Diagnostics.Internal.LogMessageAttributes)">
            <summary>
            Checks messages generated by this publisher and the provided attributes will be received by a subscriber.
            </summary>
            <param name="attributes"></param>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LogSubscriberInternal">
            <summary>
            A <see cref="T:Gemstone.Diagnostics.Internal.LogSubscriberInternal"/> that collects logs 
            </summary>
        </member>
        <member name="E:Gemstone.Diagnostics.Internal.LogSubscriberInternal.NewLogMessage">
            <summary>
            Event handler for the logs that are raised.
            </summary>
            <remarks>
            Any exceptions generated by this callback will be ignored.
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.LogSubscriberInternal.Reference">
            <summary>
            Since weak references are linked to this class, this is a common one that everyone can use when storing this weak reference.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSubscriberInternal.#ctor(System.Action)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.Internal.LogSubscriberInternal"/>
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSubscriberInternal.Clear">
            <summary>
            Clears all subscriptions
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSubscriberInternal.Subscribe(Gemstone.Diagnostics.Internal.PublisherFilter,Gemstone.Diagnostics.Internal.MessageAttributeFilter,System.Boolean)">
            <summary>
            Adds/Modify/Deletes an existing subscription
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSubscriberInternal.RaiseLogMessages(Gemstone.Diagnostics.LogMessage)">
            <summary>
            Assigns the supplied message to this subscriber.
            </summary>
            <param name="log">the message</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSubscriberInternal.OnLog(Gemstone.Diagnostics.LogMessage)">
            <summary>
            Raises the <see cref="E:Gemstone.Diagnostics.Internal.LogSubscriberInternal.NewLogMessage"/> event.
            </summary>
            <param name="logMessage">the message to raise.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSubscriberInternal.Dispose">
            <summary>
            Disposes this class so future messages will not route. 
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.LogSuppressionEngine">
            <summary>
            The suppression engine associated with an individual <see cref="T:Gemstone.Diagnostics.LogEventPublisherDetails"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSuppressionEngine.#ctor(System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="messagesPerSecond">The number of messages per second that can be generated. Must be greater than zero and less than 1 billion</param>
            <param name="burstLimit">The maximum number of messages that can be burst at one time.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.LogSuppressionEngine.IncrementPublishCount">
            <summary>
            Increments the publish count for this type of message.
            </summary>
            <returns>The suppression code assigned to this message.</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.MessageAttributeFilter">
            <summary>
            A subscription that filters which messages to sort by based on their Classification and Flags.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.MessageAttributeFilter.IsSubscribedTo(Gemstone.Diagnostics.Internal.LogMessageAttributes)">
            <summary>
            Gets if this subscription includes the provided message.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.MessageAttributeFilter.Append(Gemstone.Diagnostics.Internal.MessageAttributeFilter)">
            <summary>
            Does a Union of the two subscriptions.
            </summary>
            
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.MessageAttributeFilter.Remove(Gemstone.Diagnostics.Internal.MessageAttributeFilter)">
            <summary>
            Removes subscription A from this subscription if possible.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.MessageAttributeFilterCollection">
            <summary>
            Contains a collection of <see cref="T:Gemstone.Diagnostics.Internal.MessageAttributeFilter"/>s with the <see cref="T:Gemstone.Diagnostics.Internal.LogSubscriberInternal"/> 
            that is assigned to each segment.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.MessageAttributeFilterCollection.Routes">
            <summary>
            All of the routes that made up this filter collection
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.PublisherFilter">
            <summary>
            Describes a kind of publisher. This can be All, or a subset based on Assembly (dll) or Type (namespace/type)
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Internal.PublisherFilter.FilterType">
            <summary>
            The general classification of the subscription.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.FilterType.Universal">
            <summary>
            This will subscribe to anything, regardless of matching assembly or type. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.FilterType.Assembly">
            <summary>
            This subscription matches the name of the assembly.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.FilterType.Type">
            <summary>
            This subscription matches the full type name.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.m_filterType">
            <summary>
            The type of the filter.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.m_text">
            <summary>
            The text associated with the filter;
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.m_isExpression">
            <summary>
            Filter is an expression, this means the name contains a wildcard (* or ?)
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Internal.PublisherFilter.m_regexMatch">
            <summary>
            A <see cref="T:System.Text.RegularExpressions.Regex"/> for matching publishers if the publisher is an expression.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.#ctor(Gemstone.Diagnostics.Internal.PublisherFilter.FilterType)">
            <summary>
            Creates a either Universal or LogSource Topic
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.#ctor(Gemstone.Diagnostics.Internal.PublisherFilter.FilterType,System.String)">
            <summary>
            Creates an Assembly, Type.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.ContainsPublisher(Gemstone.Diagnostics.Internal.LogPublisherInternal)">
            <summary>
            Gets if this subscription contains the publisher.
            </summary>
            <param name="publisher">the publisher to check</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.CreateType(System.Type)">
            <summary>
            Creates a type topic on a specified type.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.CreateType(System.String)">
            <summary>
            Creates a topic from the specified list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.TrimAfterFullName(System.String)">
            <summary>
            Trims the unused information after the namespace.class+subclass details.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.CreateAssembly(System.Reflection.Assembly)">
            <summary>
            Creates a topic from the specified assembly.
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.CreateAssembly(System.String)">
            <summary>
            Creates a topic from the specified assembly file name.
            </summary>
            <param name="name">the assembly file name (.dll or .exe) </param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Internal.PublisherFilter.CreateUniversal">
            <summary>
            Creates a universal topic.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.LogEventPublisher">
            <summary>
            Can be used to publish event messages.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogEventPublisher.HasSubscribers">
            <summary>
            Gets if this publisher has any subscribers to it. This does not have to be checked as messages won't route if there are not subscribers. This is mainly
            used to skip the code that would generate the data for the <see cref="T:Gemstone.Diagnostics.LogMessage"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogEventPublisher.ShouldRaiseMessageSuppressionNotifications">
            <summary>
            Gets/Sets if a log message should be generated when message suppression occurs.
            Default is true;
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisher.Publish(System.String,System.String,System.Exception)">
            <summary>
            Raises a log message with the provided data.
            </summary>
            <param name="message"></param>
            <param name="details">A long text field with the details of the message.</param>
            <param name="exception">An exception object if one is provided.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisher.Publish(Gemstone.Diagnostics.MessageFlags,System.String,System.String,System.Exception)">
            <summary>
            Raises a log message with the provided data.
            </summary>
            <param name="flags">additional flags to set to this log</param>
            <param name="message"></param>
            <param name="details">A long text field with the details of the message.</param>
            <param name="exception">An exception object if one is provided.</param>
        </member>
        <member name="T:Gemstone.Diagnostics.LogEventPublisherDetails">
            <summary>
            Information about the <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> that published this message.
            </summary>
            <remarks>
            Since it is likely that a log file will have this data repeated a bunch, this class allows
            de-duplication of this data so it takes up less memory to store.
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.LogEventPublisherDetails.TypeData">
            <summary>
            The <see cref="T:Gemstone.Diagnostics.PublisherTypeDefinition"/> associated with <see cref="T:Gemstone.Diagnostics.LogPublisher"/> that generated the message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogEventPublisherDetails.EventName">
            <summary>
            The event name of this log message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogEventPublisherDetails.m_hashCode">
            <summary>
            A hashCode code of this owner.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.LogMessageSaveHelper)">
            <summary>
            Loads a log messages from the supplied stream
            </summary>
            <param name="stream">the stream to load the log message from.</param>
            <param name="helper">the helper to assist in loading/saving</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.#ctor(Gemstone.Diagnostics.PublisherTypeDefinition,System.String)">
            <summary>
            Represents a single owner of a log message.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.Save(System.IO.Stream,Gemstone.Diagnostics.Internal.LogMessageSaveHelper)">
            <summary>
            Writes the log data to the stream
            </summary>
            <param name="stream"></param>
            <param name="helper">the helper to assist in loading/saving</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogEventPublisherDetails.Equals(Gemstone.Diagnostics.LogEventPublisherDetails)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj"/> parameter; otherwise, false.
            </returns>
            <param name="obj">An object to compare with this object.</param>
        </member>
        <member name="T:Gemstone.Diagnostics.LogFileWriterInMemory">
            <summary>
            A log subscriber that will log messages to a file.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogFileWriterInMemory.#ctor">
            <summary>
            Creates a LogFileWriter that initially queues message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogFileWriterInMemory.LogCount">
            <summary>
            The number of logs that have been written to this file.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogFileWriterInMemory.Write(Gemstone.Diagnostics.LogMessage)">
            <summary>
            Writes the specified log to the file
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogFileWriterInMemory.ToByteArray">
            <summary>
            Returns a byte array of the log zip stream.
            </summary>
            <returns>Byte array of the log zip stream.</returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Logger">
            <summary>
            Manages the collection and reporting of logging information in a system.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Logger.ThreadLocalThreadStack.Value">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.Logger.ThreadStack"/> item for the current thread.
            Note: No exchange compare is needed since <see cref="F:Gemstone.Diagnostics.Logger.ThreadLocalThreadStack.s_localValue"/>
            is local only to the current thread.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Logger.ThreadStack">
            <summary>
            This information is maintained in a ThreadLocal variable and is about 
            messages and log suppression applied at higher levels of the calling stack.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Logger.Console">
            <summary>
            The default console based log subscriber.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Logger.FileWriter">
            <summary>
            The default file based log writer.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.Initialize">
            <summary>
            Ensures that the logger has been initialized. 
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.Shutdown">
            <summary>
            Ensures that the logger is properly shutdown.
            This is called from ShutdownHandler.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Logger.PreviousFirstChanceExceptionSequenceNumber">
            <summary>
            Gets the sequence number of the most recent First Chance Exception log 
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Logger.ShouldSuppressLogMessages">
            <summary>
            Gets if Log Messages should be suppressed.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Logger.ShouldSuppressFirstChanceLogMessages">
            <summary>
            Gets if First Chance Exception Log Messages should be suppressed.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.CreatePublisher(System.Type,Gemstone.Diagnostics.MessageClass)">
            <summary>
            Looks up the type of the log source
            </summary>
            <param name="type">the type</param>
            <param name="classification">the classification of the type of messages that this publisher will raise.</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.CreateSubscriber(Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.LogSubscriber"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.SwallowException(System.Exception,System.String,System.String,Gemstone.Diagnostics.MessageFlags)">
            <summary>
            Logs that a first chance exception was intentionally not handled for the provided reason.
            In the LogFileViewer it will filter messages differently if it was indicated that they were swallowed.
            </summary>
            <param name="ex">the exception that was swallowed</param>
            <param name="message">message to include, such as a reason why it was swallowed.</param>
            <param name="details">additional details.</param>
            <param name="additionalFlags">additional flags that can be set with this swallowed exception.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.GetStackMessages">
            <summary>
            Searches the current stack frame for all related messages that will be published with this message.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.AppendStackMessages(Gemstone.Diagnostics.LogStackMessages)">
            <summary>
            Temporarily appends data to the thread's stack so the data can be propagated to any messages generated on this thread.
            Be sure to call Dispose on the returned object to remove this from the stack.
            </summary>
            <param name="messages"></param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.SuppressLogMessages">
            <summary>
            Sets a flag that will prevent log messages from being raised on this thread.
            Remember to dispose of the callback to remove this suppression.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.SuppressFirstChanceExceptionLogMessages">
            <summary>
            Sets a flag that will prevent First Chance Exception log messages from being raised on this thread.
            Remember to dispose of the callback to remove this suppression.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.OverrideSuppressLogMessages">
            <summary>
            Sets a flag that will allow log messages to be raised again.
            Remember to dispose of the callback to remove this override.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.AppendStackMessages(System.String,System.String)">
            <summary>
            Temporarily appends data to the thread's stack so the data can be propagated to any messages generated on this thread.
            Be sure to call Dispose on the returned object to remove this from the stack.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.Logger.StackDisposal">
            <summary>
            A class that will undo a temporary change in the stack variables. Note, this class 
            will be reused. Therefore setting some kind of disposed flag will cause make this 
            class unusable. The side effect of multiple calls to Dispose is tolerable.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Logger.StackDisposal.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Gemstone.Diagnostics.LogMessage">
            <summary>
            An individual log message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.EventPublisherDetails">
            <summary>
            Contains details about the <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> that published this <see cref="T:Gemstone.Diagnostics.LogMessage"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.InitialStackMessages">
            <summary>
            The message stack that existed when the <see cref="T:Gemstone.Diagnostics.LogPublisher"/> was originally constructed.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.InitialStackTrace">
            <summary>
            The stack trace that existed when the <see cref="T:Gemstone.Diagnostics.LogPublisher"/> was originally constructed.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.CurrentStackMessages">
            <summary>
            The message stack that existed when this <see cref="T:Gemstone.Diagnostics.LogMessage"/> was published.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.CurrentStackTrace">
            <summary>
            The stack trace that existed when this <see cref="T:Gemstone.Diagnostics.LogMessage"/> was published.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.UtcTime">
            <summary>
            The time that the message was created.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.Classification">
            <summary>
            The classification of the message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.Level">
            <summary>
            The level associated with the message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.Flags">
            <summary>
            The flags associated with the message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.MessageSuppression">
            <summary>
            The suppression level assigned to this log message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.TypeName">
            <summary>
            The <see cref="T:System.Type"/> associated with <see cref="T:Gemstone.Diagnostics.LogPublisher"/> that generated the message.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.AssemblyName">
            <summary>
            The <see cref="T:System.Reflection.Assembly"/> associated with <see cref="T:Gemstone.Diagnostics.LogPublisher"/> that generated the message.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.RelatedTypes">
            <summary>
            All related types such as interfaces/parent classes for the current type.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogMessage.EventName">
            <summary>
            The event name of this log message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.Message">
            <summary>
            A specific message about the event giving more specifics about the actual message. 
            Typically, this will be up to 1 line of text. 
            Can be String.Empty.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.Details">
            <summary>
            A long text field with the details of the message. 
            Can be String.Empty.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.Exception">
            <summary>
            An exception object if one is provided.
            Can be null. 
            Since the exception is not serialized to the disk, it will be null when loaded.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.ExceptionString">
            <summary>
            A string representation of the exception. Can be String.Empty.
            If loaded from the disk, since exception objects cannot be serialized, 
            the <see cref="F:Gemstone.Diagnostics.LogMessage.Exception"/> will be null and 
            this field will have the string representation of <see cref="F:Gemstone.Diagnostics.LogMessage.Exception"/>
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.ManagedThreadID">
            <summary>
            The Managed Thread ID of the thread that created this message. This 
            is primarily to assist in future log viewing applications
            where it is beneficial to track the thread.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogMessage.PreviousFirstChanceExceptionSequenceNumber">
            <summary>
            A sequence number maintained by each thread thread of the previous 
            first chance exception that was thrown. This is used to assist
            LogFileViewer associate log messages with properly handled 
            first chance exceptions.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogMessage.#ctor(System.IO.Stream,Gemstone.Diagnostics.Internal.LogMessageSaveHelper)">
            <summary>
            Loads a log messages from the supplied stream
            </summary>
            <param name="stream">the stream to load the log message from.</param>
            <param name="saveHelper">A save helper that will condense objects</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogMessage.#ctor(Gemstone.Diagnostics.LogEventPublisherDetails,Gemstone.Diagnostics.LogStackMessages,Gemstone.Diagnostics.LogStackTrace,Gemstone.Diagnostics.LogStackMessages,Gemstone.Diagnostics.LogStackTrace,Gemstone.Diagnostics.Internal.LogMessageAttributes,System.String,System.String,System.Exception)">
            <summary>
            Creates a log message
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Gemstone.Diagnostics.LogMessage.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogMessage.Save(System.IO.Stream,Gemstone.Diagnostics.Internal.LogMessageSaveHelper)">
            <summary>
            Writes the log data to the stream
            </summary>
            <param name="stream"></param>
            <param name="saveHelper"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogMessage.GetMessage">
            <summary>
            Gets the details of the message.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.LogPublisher">
            <summary>
            A publisher of log messages. 
            </summary>
            <remarks>
            <see cref="F:Gemstone.Diagnostics.LogPublisher.InitialStackMessages"/> and <see cref="F:Gemstone.Diagnostics.LogPublisher.InitialStackTrace"/> can be modified so messages that are generated 
            with this instance will have this data appended to the log message.
            
            The user can either call one of the Publish overloads to lazily publish a message, or they
            can register a message with RegisterEvent so calling this message will incur little overhead.
            If registering an event, the user can check <see cref="P:Gemstone.Diagnostics.LogEventPublisher.HasSubscribers"/> to determine if the log message can be skipped altogether. 
            Registering events also allows the user to specify the auto-suppression algorithm and the depth of the stack trace that will be recorded on a message being raised.
            
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.LogPublisher.m_logger">
            <summary>
            Occurs when a new <see cref="T:Gemstone.Diagnostics.LogMessage"/> is ready to be published.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogPublisher.InitialStackMessages">
            <summary>
            The stack messages that existed when this publisher was created. This can be modified by the user of this publisher.
            Any messages that get published by this class will automatically have this data added to the log message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogPublisher.InitialStackTrace">
            <summary>
            The stack trace that existed when this publisher was created. This can be modified by the user of this publisher.
            Any messages that get published by this class will automatically have this data added to the log message.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogPublisher.MaxDistinctEventPublisherCount">
            <summary>
            The maximum number of distinct events that this publisher can generate. (Default: 20)
            </summary>
            <remarks>
            Since message suppression and collection occurs at the event name level, it is important
            to have only a few distinct message types. This is the limit so misapplication
            of this publisher will not cause memory impacts on the system.
            
            It is recommended to keep the event name as a fixed string and not report any other meta data
            with the event.
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.LogPublisher.m_lookupEventPublishers">
            <summary>
            Where the <see cref="T:Gemstone.Diagnostics.Internal.LogEventPublisherInternal"/>s of specific events are cached.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.RegisterEvent(Gemstone.Diagnostics.MessageLevel,System.String)">
            <summary>
            Initializes an <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> with the provided values.
            </summary>
            <param name="level">the level of the message and associated flags if any</param>
            <param name="eventName">the name of the event.</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.RegisterEvent(Gemstone.Diagnostics.MessageLevel,Gemstone.Diagnostics.MessageFlags,System.String)">
            <summary>
            Initializes an <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> with the provided values.
            </summary>
            <param name="level">the level of the message</param>
            <param name="flags">associated flags</param>
            <param name="eventName">the name of the event.</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.RegisterEvent(Gemstone.Diagnostics.MessageLevel,System.String,System.Int32,Gemstone.Diagnostics.MessageRate,System.Int32)">
            <summary>
            Initializes an <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> with the provided values.
            </summary>
            <param name="level">the level of the message</param>
            <param name="eventName"></param>
            <param name="stackTraceDepth"></param>
            <param name="messagesPerSecond"></param>
            <param name="burstLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.RegisterEvent(Gemstone.Diagnostics.MessageLevel,Gemstone.Diagnostics.MessageFlags,System.String,System.Int32,Gemstone.Diagnostics.MessageRate,System.Int32)">
            <summary>
            Initializes an <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> with the provided values.
            </summary>
            <param name="level">the level of the message</param>
            <param name="flags">associated flags</param>
            <param name="eventName"></param>
            <param name="stackTraceDepth"></param>
            <param name="messagesPerSecond"></param>
            <param name="burstLimit"></param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.ToString">
            <summary>
            Gets the full name of the type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.Publish(Gemstone.Diagnostics.MessageLevel,System.String,System.String,System.String,System.Exception)">
            <summary>
            Raises a log message with the provided data.
            </summary>
            <param name="level">the level of the message</param>
            <param name="eventName">A short name about what this message is detailing. Typically this will be a few words.</param>
            <param name="message"> A longer message than <see param="eventName"/> giving more specifics about the actual message. 
            Typically, this will be up to 1 line of text.</param>
            <param name="details">A long text field with the details of the message.</param>
            <param name="exception">An exception object if one is provided.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.Publish(Gemstone.Diagnostics.MessageLevel,Gemstone.Diagnostics.MessageFlags,System.String,System.String,System.String,System.Exception)">
            <summary>
            Raises a log message with the provided data.
            </summary>
            <param name="level">the level of the message</param>
            <param name="flags">associated flags</param>
            <param name="eventName">A short name about what this message is detailing. Typically this will be a few words.</param>
            <param name="message"> A longer message than <see param="eventName"/> giving more specifics about the actual message. 
            Typically, this will be up to 1 line of text.</param>
            <param name="details">A long text field with the details of the message.</param>
            <param name="exception">An exception object if one is provided.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.InternalRegisterEvent(Gemstone.Diagnostics.Internal.LogMessageAttributes,System.String)">
            <summary>
            Initializes an <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> with a series of settings.
            </summary>
            <param name="attributes"></param>
            <param name="eventName">the name of the event.</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogPublisher.InternalRegisterEvent(Gemstone.Diagnostics.Internal.LogMessageAttributes,System.String,System.Int32,Gemstone.Diagnostics.MessageRate,System.Int32)">
            <summary>
            Initializes an <see cref="T:Gemstone.Diagnostics.LogEventPublisher"/> with a series of settings.
            </summary>
            <param name="attributes"></param>
            <param name="eventName"></param>
            <param name="stackTraceDepth"></param>
            <param name="messagesPerSecond"></param>
            <param name="burstLimit"></param>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.LogStackFrame">
            <summary>
            Provides information about the specific stack frame.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackFrame.ClassName">
            <summary>
            The name of the method's type.
            </summary>
            <remarks>
            Example: System.Collections.Generic.List`1+Enumerable
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackFrame.MethodName">
            <summary>
            The name of the method
            </summary>
            <remarks>
            Example: MethodName&lt;TKey,TValue&gt;(String key, String value)
            </remarks>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackFrame.FileName">
            <summary>
            The file name if debug symbols were compiled with the assembly
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackFrame.NativeOffset">
            <summary>
            Gets the offset position in the IL Code.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackFrame.LineNumber">
            <summary>
            The line number of the data.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackFrame.ColumnNumber">
            <summary>
            The column number of the execution point.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.#ctor(System.Diagnostics.StackFrame)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.LogStackFrame"/> from a <see cref="T:System.Diagnostics.StackFrame"/>
            </summary>
            <param name="frame"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.#ctor(System.IO.Stream)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.LogStackFrame"/> from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">the stream to load from</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.Save(System.IO.Stream)">
            <summary>
            Saves this class to a <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream">the stream to write to.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.ToString">
            <summary>
            Makes a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.ToString(System.Text.StringBuilder)">
            <summary>
            Appends the details of this stack frame to the provided <see param="stringBuilder"/>.
            </summary>
            <param name="stringBuilder">where to append this class information</param>
            <remarks>
            Does not append a <see cref="P:System.Environment.NewLine"/> to the end of the line.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.ComputeHashCode">
            <summary>
            Gets the hash code data from this frame
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackFrame.Equals(Gemstone.Diagnostics.LogStackFrame)">
            <summary>
            Gets of the two classes are equal
            </summary>
            <param name="other">the class to compare.</param>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.LogStackMessages">
            <summary>
            Represents an immutable list of stack messages.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.#ctor(System.String[])">
            <summary>
            Creates a new stack message from the provided list of key/value pairs.
            </summary>
            <param name="keyValuePairs">Key/value pairs, e.g., key1, value1, key2, value2, ..., key(n), value(n).</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.#ctor(System.String,System.String)">
            <summary>
            Creates a new stack message from the provided <paramref name="key"/> and <paramref name="value"/>.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">if key or value are null or whitespace.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.#ctor(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Appends stack messages together.
            </summary>
            <param name="messages">the messages</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.#ctor(System.Collections.Generic.List{Gemstone.Diagnostics.LogStackMessages})">
            <summary>
            Appends stack messages together.
            </summary>
            <param name="messages">the messages</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.#ctor(Gemstone.Diagnostics.LogStackMessages,Gemstone.Diagnostics.LogStackMessages)">
            <summary>
            Appends stack messages together.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.#ctor(System.IO.Stream)">
            <summary>
            Loads stack messages from the stream.
            </summary>
            <param name="stream">the stream to load from</param>
            <exception cref="T:System.Data.VersionNotFoundException">if the version is not recognized.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.LogStackMessages.Count">
            <summary>
            Gets the number of Key/Value pairs.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.LogStackMessages.Item(System.Int32)">
            <summary>
            Gets the KeyValue for the provided index.
            </summary>
            <param name="index">The Index</param>
        </member>
        <member name="P:Gemstone.Diagnostics.LogStackMessages.Item(System.String)">
            <summary>
            Gets the first match of the provided <see pref="key"/> in this dictionary. Returns
            null if none can be found.
            </summary>
            <param name="key">The Index</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.Union(System.String,System.String)">
            <summary>
            returns the union of this instance and the specified key/value. 
            If the key already exists. The new one replaces the existing one.
            </summary>
            <param name="key">a key</param>
            <param name="value">a value</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">if Key or Value are null or whitespace.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.Union(System.String[])">
            <summary>
            returns the union of this instance and the specified list of key/value pairs. 
            If the keys already exists. The new one replaces the existing one.
            </summary>
            <param name="keyValuePairs">Key/value pairs, e.g., key1, value1, key2, value2, ..., key(n), value(n).</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">if Key or Value are null or whitespace.</exception>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.Union(Gemstone.Diagnostics.LogStackMessages)">
            <summary>
            returns the union of this instance and the specified <see pref="stackMessage"/>
            New messages replace existing messages.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.Save(System.IO.Stream)">
            <summary>
            Saves this instance to the provided stream
            </summary>
            <param name="stream">the stream to save.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.Equals(Gemstone.Diagnostics.LogStackMessages)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackMessages.ToString">
            <summary>Returns a string that represents the current object.</summary>
            <returns>A string that represents the current object.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackMessages.Empty">
            <summary>
            An empty stack message.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.LogStackTrace">
            <summary>
            Provides stack trace data that can be serialized to a stream.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackTrace.m_frames">
            <summary>
            Gets the stack frame data
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackTrace.Frames">
            <summary>
            Gets the stack frame data
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackTrace.m_hashCode">
            <summary>
            Gets the hashcode for this class
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.#ctor">
            <summary>
            Creates the <see cref="F:Gemstone.Diagnostics.LogStackTrace.Empty"/> object
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.#ctor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Creates a stack trace object
            </summary>
            <param name="lookupFileInfo">gets if the file paths need to be looked up.</param>
            <param name="skipCount">the number of frames to skip.</param>
            <param name="maxStackFrames">the maximum number of frames in the stack trace.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.#ctor(System.IO.Stream)">
            <summary>
            Loads stack trace information from the supplied <see param="stream"/>
            </summary>
            <param name="stream">where to load the stack trace information</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.Save(System.IO.Stream)">
            <summary>
            Saves stack trace information to the supplied <see param="stream"/>
            </summary>
            <param name="stream">where to save the stack trace information</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.LogStackTrace.Equals(Gemstone.Diagnostics.LogStackTrace)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="F:Gemstone.Diagnostics.LogStackTrace.Empty">
            <summary>
            An empty stack trace.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.LogSubscriber">
            <summary>
            Subscribes to log events.
            </summary>
        </member>
        <member name="E:Gemstone.Diagnostics.LogSubscriber.NewLogMessage">
            <summary>
            Event handler for the logs that are raised.
            </summary>
            <remarks>
            Any exceptions generated by this callback will be ignored.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.#ctor(Gemstone.Diagnostics.Internal.LogSubscriberInternal)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.LogSubscriber"/>
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.SubscribeToAll(Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Subscribes to all publishers with the specified verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.SubscribeToType(System.Type,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Subscribes to the publisher of the specified type with the specified verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.SubscribeToType(System.String,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Subscribes to the publisher of the specified type expression with the specified verbose level.
            </summary>
            <param name="typeExpression">An expression of the name of a type. Must include a * or ? to be considered an expression.</param>
            <param name="level">The level</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.SubscribeToAssembly(System.Reflection.Assembly,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Subscribes to the publisher of the specified assembly with the specified verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.SubscribeToAssembly(System.String,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Subscribes to the publisher of the specified assembly with the specified verbose level.
            </summary>
             /// <param name="assemblyExpression">An expression of the name of an assembly. Must include a * or ? to be considered an expression.</param>
            <param name="level">The level</param>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.IgnoreAll(Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Ignore all messages of this verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.IgnoreType(System.Type,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Ignore all messages of this verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.IgnoreType(System.String,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Ignore all messages of this verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.IgnoreAssembly(System.Reflection.Assembly,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Ignore all messages of this verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.IgnoreAssembly(System.String,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Ignore all messages of this verbose level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.Clear">
            <summary>
            Clears all subscriptions
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.LogSubscriber.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageClass">
            <summary>
            Gets the classification of the message. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageClass.Component">
            <summary>
            Messages that come from core components. These messages are for classes that 
            are not working towards a specific framework or application, but can 
            generally be used. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageClass.Framework">
            <summary>
            Messages from higher level software components. A framework is what makes the underlying application work and 
            is the assimilation of components for a specific purpose. Use this if the intent is that this
            code will be shared among many different applications and may be implemented differently in those applications. 
            This is different from Component as it has a more specific and defined purpose.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageClass.Application">
            <summary>
            These messages are for the highest layer of an application. 
            Messages like 'Application X is starting up, shutting down' would go here.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageFlags">
            <summary>
            Various flags that can be attributed to a <see cref="T:Gemstone.Diagnostics.LogMessage"/>. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageFlags.None">
            <summary>
            No flags are specified.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageFlags.UsageIssue">
            <summary>
            Indicates that a segment of code is not being used properly or ideally.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageFlags.BugReport">
            <summary>
            Indicates that a issue in the code exists somewhere. This is helpful when the programmer suspects that 
            certain exceptions were not properly handled.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageFlags.PerformanceIssue">
            <summary>
            A flag indicating that a performance related issue has occurred. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageFlags.SecurityMessage">
            <summary>
            Indicates this message has security implications with it. Such as 
            a successful/unsuccessful authentication.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageFlags.SystemHealth">
            <summary>
            These messages in generally should always be logged because they report the state of the current system's health. Normally this 
            will be when the system health is abnormal, for example, something abnormal is happening in the background that is important to 
            note and can assist debugging other components. Messages raised here would include First Chance Exceptions 
            and exceptions in log message routing (such as Message Suppression).
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageLevel">
            <summary>
            The level of importance of a message that is being raised. Increasing from Debug, Info, Warning, Error, Critical.
            None can be specified, but this indicates an importance level cannot be properly identified, and the message
            will be routed based on <see cref="T:Gemstone.Diagnostics.MessageFlags"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevel.NA">
            <summary>
            Indicates a level that cannot be generally subscribed to. In this case,
            the message can only be subscribed to if a <see cref="T:Gemstone.Diagnostics.MessageFlags"/> is subscribed to.
            Example: First Chance AppDomain Exceptions could fall under here because it's impossible
            to assign the risk of this king of exception. Instead the SystemHealth flag will be raised.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevel.Debug">
            <summary>
            Indicates a message that may assist in debugging code and generally
            serves no additional purpose. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevel.Info">
            <summary>
            Indicates that the message is informational. No action should be taken
            for these type of messages.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevel.Warning">
            <summary>
            Indicates that something happened that might adversely affect the system's operation.
            This level can also be used for expected errors. Warnings can be precursors
            to errors in the system. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevel.Error">
            <summary>
            Indicates that something happened that might adversely affect the system's operation.
            This level should be reserved for errors that are not expected to occur. 
            These are non-urgent failures to the system.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevel.Critical">
            <summary>
            Indicates that something happened that will render certain components useless. These
            errors can be recovered from. An example case would be one of those 
            "this should never happen" errors that were likely not handled properly and thus could
            eventually make the system unstable or unusable.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageLevelFlags">
            <summary>
            The level of importance of a message that is being raised. Increasing from Debug, Info, Warning, Error, Critical.
            None can be specified, but this indicates an importance level cannot be properly identified, and the message
            will be routed based on <see cref="T:Gemstone.Diagnostics.MessageFlags"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevelFlags.NA">
            <summary>
            Indicates a level that cannot be generally subscribed to. In this case,
            the message can only be subscribed to if a <see cref="T:Gemstone.Diagnostics.MessageFlags"/> is subscribed to.
            Example: First Chance AppDomain Exceptions could fall under here because it's impossible
            to assign the risk of this king of exception. Instead the SystemHealth flag will be raised.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevelFlags.Debug">
            <summary>
            Indicates a message that may assist in debugging code and generally
            serves no additional purpose. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevelFlags.Info">
            <summary>
            Indicates that the message is informational. No action should be taken
            for these type of messages.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevelFlags.Warning">
            <summary>
            Indicates that something happened that might adversely affect the system's operation.
            This level can also be used for expected errors. Warnings can be precursors
            to errors in the system. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevelFlags.Error">
            <summary>
            Indicates that something happened that might adversely affect the system's operation.
            This level should be reserved for errors that are not expected to occur. 
            These are non-urgent failures to the system.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageLevelFlags.Critical">
            <summary>
            Indicates that something happened that will render certain components useless. These
            errors can be recovered from. An example case would be one of those 
            "this should never happen" errors that were likely not handled properly and thus could
            eventually make the system unstable or unusable.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageRate">
            <summary>
            Defines a message rate for the message suppression algorithm
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageRate.m_rate">
            <summary>
            The rate in messages per second. (add 1 to this time, so the default is 1 message per second)
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageRate.Default">
            <summary>
            Gets the default message rate. Which is 1 message per second.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.PerSecond(System.Double)">
            <summary>
            As messages per second.
            </summary>
            <param name="messagesPerSecond">the number of messages to allow per second</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.PerMinute(System.Double)">
            <summary>
            As messages per minute.
            </summary>
            <param name="messagesPerMinute">the number of messages to allow per minute</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.PerHour(System.Double)">
            <summary>
            As messages per hour.
            </summary>
            <param name="messagesPerHour">the number of messages to allow per hour</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.PerDay(System.Double)">
            <summary>
            As messages per day.
            </summary>
            <param name="messagesPerDay">the number of messages to allow per day</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.EveryFewSeconds(System.Double)">
            <summary>
            As a minimum timespan between each message.
            </summary>
            <param name="separation">the number of seconds between messages</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.EveryFewMinutes(System.Double)">
            <summary>
            As a minimum timespan between each message.
            </summary>
            <param name="separation">the number of Minutes between messages</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.EveryFewHours(System.Double)">
            <summary>
            As a minimum timespan between each message.
            </summary>
            <param name="separation">the number of Hours between messages</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.EveryFewDays(System.Double)">
            <summary>
            As a minimum timespan between each message.
            </summary>
            <param name="separation">the number of Days between messages</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.MessageRate.op_Implicit(Gemstone.Diagnostics.MessageRate)~System.Double">
            <summary>
            Implicitly convert the message rate to a rate per second.
            </summary>
            <param name="rate">the item to convert.</param>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageSuppression">
            <summary>
            Indicates the suppression level that this message received
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppression.None">
            <summary>
            This message did not receive a suppression level.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppression.Standard">
            <summary>
            Indicates that the message rate is slightly over normal levels. Only subscribers specifically
            asking for this suppression level will receive this message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppression.Heavy">
            <summary>
            Indicates that the message rate is heavily over normal levels. Only subscribers specifically
            asking for this suppression level will receive this message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppression.Severe">
            <summary>
            Indicates that the message rate is severely over normal levels. Only subscribers specifically
            asking for this suppression level will receive this message.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.MessageSuppressionFlags">
            <summary>
            Indicates the suppression level that this message received
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppressionFlags.None">
            <summary>
            This message did not receive a suppression level.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppressionFlags.Standard">
            <summary>
            Indicates that the message rate is slightly over normal levels. Only subscribers specifically
            asking for this suppression level will receive this message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppressionFlags.Heavy">
            <summary>
            Indicates that the message rate is heavily over normal levels. Only subscribers specifically
            asking for this suppression level will receive this message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.MessageSuppressionFlags.Severe">
            <summary>
            Indicates that the message rate is severely over normal levels. Only subscribers specifically
            asking for this suppression level will receive this message.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.NamespaceDoc">
            <summary>
            The <see cref="N:Gemstone.Diagnostics"/> namespace organizes all Gemstone library functionality
            related to diagnostics. The root diagnostics namespace also includes common diagnostics classes,
            e.g., <see cref="T:Gemstone.Diagnostics.LogPublisher"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.NewLogMessageEventHandler">
            <summary>
            A log message delegate
            </summary>
            <param name="logMessage">the log message</param>
        </member>
        <member name="T:Gemstone.Diagnostics.PerformanceCounter">
             <summary>
             Represents an extension of the basic <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> providing additional statistical logic.
             </summary>
             <example>
             This example shows how to create a performance counter for processor utilization:
             <code>
             using System;
             using System.Threading;
             using Gemstone.Diagnostics;
            
             class Program
             {
                 static void Main(string[] args)
                 {
                     PerformanceCounter counter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
                     while (true)
                     {
                         Thread.Sleep(1000);
                         counter.Sample();
                         Console.WriteLine(string.Format("Last value: {0}", counter.LastValue));
                         Console.WriteLine(string.Format("Minimum value: {0}", counter.MinimumValue));
                         Console.WriteLine(string.Format("Maximum value: {0}", counter.MaximumValue));
                         Console.WriteLine(string.Format("Average value: {0}", counter.AverageValue));
                         Console.WriteLine(new string('-', 30));
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="F:Gemstone.Diagnostics.PerformanceCounter.DefaultValueUnit">
            <summary>
            Default measurement unit of the statistical values.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PerformanceCounter.DefaultValueDivisor">
            <summary>
            Default divisor to be applied to the statistical value.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PerformanceCounter.DefaultSamplingWindow">
            <summary>
            Default number of samples over which statistical values are to be calculated.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> class.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> class.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
            <param name="aliasName">The alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> class.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
            <param name="aliasName">The alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="valueUnit">The measurement unit for the statistical values of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.#ctor(System.String,System.String,System.String,System.String,System.String,System.Single,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> class.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
            <param name="aliasName">The alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="valueUnit">The measurement unit for the statistical values of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="valueDivisor">The divisor to be applied to the statistical values of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="readOnly">Flag that determines if this counter is read-only.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Diagnostics.PerformanceCounter" /> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.AliasName">
            <summary>
            Gets or sets an alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.ValueUnit">
            <summary>
            Gets or sets the measurement unit of <see cref="P:Gemstone.Diagnostics.PerformanceCounter.LastValue"/>, <see cref="P:Gemstone.Diagnostics.PerformanceCounter.MinimumValue"/>, 
            <see cref="P:Gemstone.Diagnostics.PerformanceCounter.MaximumValue"/> and <see cref="P:Gemstone.Diagnostics.PerformanceCounter.AverageValue"/>
            </summary>
            <exception cref="T:System.ArgumentNullException">The value being assigned is a null or empty string.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.ValueDivisor">
            <summary>
            Gets or sets the divisor to be applied to the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.LastValue"/>, <see cref="P:Gemstone.Diagnostics.PerformanceCounter.MinimumValue"/>, 
            <see cref="P:Gemstone.Diagnostics.PerformanceCounter.MaximumValue"/> and <see cref="P:Gemstone.Diagnostics.PerformanceCounter.AverageValue"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value being assigned is not greater than 0.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.SamplingWindow">
            <summary>
            Gets or sets the number of samples to use to determine the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.LastValue"/>, 
            <see cref="P:Gemstone.Diagnostics.PerformanceCounter.MinimumValue"/>, <see cref="P:Gemstone.Diagnostics.PerformanceCounter.MaximumValue"/> and <see cref="P:Gemstone.Diagnostics.PerformanceCounter.AverageValue"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">The value being assigned is not greater than 0.</exception>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.Samples">
            <summary>
            Gets a list of sampled values from the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.LastValue">
            <summary>
            Gets the last sample value from the samples of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.MinimumValue">
            <summary>
            Gets the minimum sample value from the samples of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.MaximumValue">
            <summary>
            Gets the maximum sample value from the samples of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.AverageValue">
            <summary>
            Gets the average value from the samples of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.LifetimeMaximumValue">
            <summary>
            Gets the maximum sample value over the entire lifetime of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.LifetimeAverageValue">
            <summary>
            Gets the average sample value over the entire lifetime of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.LifetimeSampleCount">
            <summary>
            Gets the total values sampled over the entire lifetime of the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object that this <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> objects wraps.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.SampleAdjuster">
            <summary>
            Gets or sets an optional custom sample adjustment function. Can be used to apply linear adjustments to sampled values.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceCounter.SampleFilter">
            <summary>
            Gets or sets an optional custom sample filter function. Can be used to skip sampled values that are unreasonable.
            </summary>
            <remarks>
            Return <c>true</c> if sample should be filtered; otherwise, <c>false</c>.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Diagnostics.PerformanceCounter" /> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Diagnostics.PerformanceCounter" /> object and optionally 
            releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.Sample">
            <summary>
            Obtains a sample value from the <see cref="P:Gemstone.Diagnostics.PerformanceCounter.BaseCounter"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceCounter.Reset">
            <summary>
            Resets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object to its initial state.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.PerformanceMonitor">
             <summary>
             Represents a process performance monitor that operates similar to the Windows Performance Monitor utility
             that can be used to monitor system performance.
             </summary>
             <example>
             This example shows how to use <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> for monitoring application performance:
             <code>
             using System;
             using System.Threading;
             using Gemstone.Diagnostics;
            
             class Program
             {
                 static void Main(string[] args)
                 {
                     PerformanceMonitor perfMon = new PerformanceMonitor();
                     while (true)
                     {
                         // Display process performance.
                         Thread.Sleep(5000);
                         Console.WriteLine("");
                         Console.Write(perfMon.Status);
                     }
                 }
             }
             </code>
             </example>
             <seealso cref="T:Gemstone.Diagnostics.PerformanceCounter"/>
        </member>
        <member name="F:Gemstone.Diagnostics.PerformanceMonitor.ThreadPoolCountersCategoryName">
            <summary>
            Name of the custom thread pool counters category.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitor.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> class.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitor.#ctor(System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> class.
            </summary>
            <param name="samplingInterval">Interval, in milliseconds, at which the <see cref="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters"/> are to be sampled.</param>
            <param name="addDefaultCounters">Set to <c>true</c> to add default counters; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitor.#ctor(System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> class.
            </summary>
            <param name="processName">Name of the <see cref="T:System.Diagnostics.Process"/> whose performance is to be monitored.</param>
            <param name="addDefaultCounters">Set to <c>true</c> to add default counters; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitor.#ctor(System.String,System.Double,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> class.
            </summary>
            <param name="processName">Name of the <see cref="T:System.Diagnostics.Process"/> whose performance is to be monitored.</param>
            <param name="samplingInterval">Interval, in milliseconds, at which the <see cref="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters"/> are to be sampled.</param>
            <param name="addDefaultCounters">Set to <c>true</c> to add default counters; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitor.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.ProcessName">
            <summary>
            Gets or sets the name of the <see cref="T:System.Diagnostics.Process"/> to be monitored.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.CPUUsage">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the processor utilization of the monitored process.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.IPDataSendRate">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the IP based datagrams sent / second of the system.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.IPDataReceiveRate">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the IP based datagrams received / second of the system.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.ThreadingContentionRate">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the .NET threading contention rate / second of the process.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.MemoryUsage">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the memory utilization of the monitored process.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.IOUsage">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the rate at which the monitored process is 
            issuing bytes to I/O operations that do not involve data such as control operations.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.IOActivity">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the rate at which the monitored process is 
            issuing read and write I/O operations.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.HandleCount">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the total number of handles currently open by 
            the monitored process.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.ThreadCount">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the number of threads currently active in the 
            monitored process.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitor.Name">
            <summary>
            Gets the friendly name of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitor.SampleCustomCounters">
            <summary>
            Handle sampling of custom counters.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.PerformanceMonitorBase">
            <summary>
            Represents a base class for performance monitors, e.g., the process level <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/>
            and the system level <see cref="T:Gemstone.Diagnostics.SystemPerformanceMonitor"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PerformanceMonitorBase.DefaultSamplingInterval">
            <summary>
            Default interval for sampling the <see cref="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitorBase"/> class.
            </summary>
            <param name="samplingInterval">Interval, in milliseconds, at which the <see cref="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters"/> are to be sampled.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitorBase.SamplingInterval">
            <summary>
            Gets or sets the interval, in milliseconds, at which the <see cref="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters"/> are to be sampled.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters">
            <summary>
            Gets a read-only list of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> objects monitored by the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> object.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitorBase.Name">
            <summary>
            Gets the friendly name of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitorBase"/> object.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitorBase.Status">
            <summary>
            Gets the current status of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitorBase"/> object.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.PerformanceMonitorBase.LifetimeStatus">
            <summary>
            Gets the lifetime status statistics of the <see cref="T:Gemstone.Diagnostics.PerformanceMonitor"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Diagnostics.PerformanceMonitorBase"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Diagnostics.PerformanceMonitorBase"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.AddCounter(System.String,System.String,System.String)">
            <summary>
            Adds a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be monitored.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.AddCounter(System.String,System.String,System.String,System.String)">
            <summary>
            Adds a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be monitored.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
            <param name="aliasName">The alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.AddCounter(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Adds a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be monitored.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
            <param name="aliasName">The alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="valueUnit">The measurement unit for the statistical values of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.AddCounter(System.String,System.String,System.String,System.String,System.String,System.Single,System.Boolean,System.Func{System.Single,System.Single},System.Func{System.Single,System.Boolean})">
            <summary>
            Adds a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be monitored.
            </summary>
            <param name="categoryName">The name of the performance counter category (performance object) with which this performance counter is associated.</param>
            <param name="counterName">The name of the performance counter.</param>
            <param name="instanceName">The name of the performance counter category instance, or an empty string (""), if the category contains a single instance.</param>
            <param name="aliasName">The alias name for the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="valueUnit">The measurement unit for the statistical values of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="valueDivisor">The divisor to be applied to the statistical values of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object.</param>
            <param name="readOnly">Flag that determines if this counter is read-only.</param>
            <param name="sampleAdjuster">Defines a custom sample adjustment function for the counter.</param>
            <param name="sampleFilter">Defines a custom sample filter function for the counter.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.AddCounter(Gemstone.Diagnostics.PerformanceCounter)">
            <summary>
            Adds a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be monitored.
            </summary>
            <param name="counter">The <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object to be monitored.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.RemoveCounter(Gemstone.Diagnostics.PerformanceCounter)">
            <summary>
            Removes a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> being monitored.
            </summary>
            <param name="counter">The <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object to be unmonitored.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.FindCounter(System.String)">
            <summary>
            Returns a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object matching the specified counter name.
            </summary>
            <param name="counterName">Name of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be retrieved.</param>
            <returns>A <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object if a match is found; otherwise null.</returns>
            <remarks>
            First <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> with matching name is returned. If same name exists within
            multiple monitored categories, use <see cref="M:Gemstone.Diagnostics.PerformanceMonitorBase.FindCounter(System.String,System.String)"/> overload instead.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.FindCounter(System.String,System.String)">
            <summary>
            Returns a <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object matching the specified counter name.
            </summary>
            <param name="categoryName">Category of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be retrieved.</param>
            <param name="counterName">Name of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be retrieved.</param>
            <returns>A <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> object if a match is found; otherwise null.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.FindCounters(System.String)">
            <summary>
            Returns <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> array matching the specified counter name.
            </summary>
            <param name="counterName">Name of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be retrieved.</param>
            <returns>A <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> array of found matches, if any.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.FindCounters(System.String,System.String)">
            <summary>
            Returns <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> array matching the specified counter name.
            </summary>
            <param name="categoryName">Category of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be retrieved.</param>
            <param name="counterName">Name of the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> to be retrieved.</param>
            <returns>A <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> array of found matches, if any.</returns>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.SampleCounters">
            <summary>
            Sample all defined counters.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PerformanceMonitorBase.SampleCustomCounters">
            <summary>
            Derived class should override this method to sample any custom counters.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.ProcessUtilizationCalculator">
            <summary>
            Represents a utilization calculator for a related <see cref="T:System.Diagnostics.Process"/> set.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.ProcessUtilizationCalculator.DefaultUpdateInterval">
            <summary>
            Default value for the <see cref="P:Gemstone.Diagnostics.ProcessUtilizationCalculator.UpdateInterval"/> property.
            </summary>
        </member>
        <member name="E:Gemstone.Diagnostics.ProcessUtilizationCalculator.StatusMessage">
            <summary>
            Provides status messages to consumer.
            </summary>
            <remarks>
            <see cref="F:Gemstone.EventArgs`1.Argument"/> is new status message.
            </remarks>
        </member>
        <member name="M:Gemstone.Diagnostics.ProcessUtilizationCalculator.#ctor">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.ProcessUtilizationCalculator"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.ProcessUtilizationCalculator.Utilization">
            <summary>
            Gets the current processor utilization, percent between 0.0 and 1.0, of the associated <see cref="T:System.Diagnostics.Process"/> set.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.ProcessUtilizationCalculator.UpdateInterval">
            <summary>
            Gets or sets the interval, in milliseconds, over which <see cref="P:Gemstone.Diagnostics.ProcessUtilizationCalculator.Utilization"/> will be calculated.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.ProcessUtilizationCalculator.AssociatedProcesses">
            <summary>
            Gets associated processes for this <see cref="T:Gemstone.Diagnostics.ProcessUtilizationCalculator"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ProcessUtilizationCalculator.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Diagnostics.ProcessUtilizationCalculator"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ProcessUtilizationCalculator.Initialize(System.Diagnostics.Process[])">
            <summary>
            Starts calculating the total processor utilization of the specified <paramref name="processes"/>.
            </summary>
            <param name="processes">The <see cref="T:System.Diagnostics.Process"/> set, e.g., parent and child processes, to monitor for total processor utilization.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.ProcessUtilizationCalculator.Initialize(System.Collections.Generic.IEnumerable{System.Diagnostics.Process})">
            <summary>
            Starts calculating the total processor utilization of the specified <paramref name="processes"/>.
            </summary>
            <param name="processes">The <see cref="T:System.Diagnostics.Process"/> set, e.g., parent and child processes, to monitor for total processor utilization.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.ProcessUtilizationCalculator.Refresh">
            <summary>
            Refreshes the processor utilization of the associated <see cref="T:System.Diagnostics.Process"/> set.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.PublisherTypeDefinition">
            <summary>
            Contains all of the metadata associated with a <see cref="T:System.Type"/> that will 
            be serialized to the disk.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PublisherTypeDefinition.TypeName">
            <summary>
            The <see cref="T:System.Type"/> associated with <see cref="T:Gemstone.Diagnostics.LogPublisher"/> that generated the message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PublisherTypeDefinition.AssemblyName">
            <summary>
            The <see cref="T:System.Reflection.Assembly"/> associated with <see cref="T:Gemstone.Diagnostics.LogPublisher"/> that generated the message.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PublisherTypeDefinition.AssemblyVersion">
            <summary>
            Gets the version number of the <see cref="T:System.Reflection.Assembly"/> that this <see cref="T:Gemstone.Diagnostics.LogPublisher"/>'s type 
            belongs to.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PublisherTypeDefinition.RelatedTypes">
            <summary>
            All related types such as interfaces/parent classes for the current type.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.PublisherTypeDefinition.m_hashCode">
            <summary>
            A hashCode code of this owner.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.#ctor(System.Type)">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.PublisherTypeDefinition"/> by looking it up from <see pref="type"/>.
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.#ctor(System.IO.Stream)">
            <summary>
            Loads a log messages from the supplied stream
            </summary>
            <param name="stream">the stream to load the log message from.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.#ctor(System.String,System.String)">
            <summary>
            A backwards compatible means of generating this type data if <see cref="T:System.Type"/> is not available.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.Save(System.IO.Stream)">
            <summary>
            Writes the log data to the stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.Equals(Gemstone.Diagnostics.PublisherTypeDefinition)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="obj"/> parameter; otherwise, false.
            </returns>
            <param name="obj">An object to compare with this object.</param>
        </member>
        <member name="M:Gemstone.Diagnostics.PublisherTypeDefinition.TrimAfterFullName(System.String)">
            <summary>
            Trims the unused information after the namespace.class+subclass details.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Diagnostics.ShutdownHandlerOrder">
            <summary>
            The order in which the specified callback should occur when shutting down.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.ShutdownHandlerOrder.First">
            <summary>
            This queue is processed first. Unless there is a compelling reason to execute first, select the Default one. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.ShutdownHandlerOrder.Default">
            <summary>
            This shutdown order occurs after First, but before Last. 
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.ShutdownHandlerOrder.Last">
            <summary>
            This queue is processed last. Items such as flushing application logs should go here.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.ShutdownHandler">
            <summary>
            This class will monitor the state to the application and raise events when it detects that the application is about to shutdown.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.ShutdownHandler.IsShuttingDown">
            <summary>
            Gets if this process is shutting down.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.ShutdownHandler.HasShutdown">
            <summary>
            Gets if this process has already shut down.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ShutdownHandler.Initialize">
            <summary>
            Initializes the shutdown handler. This is recommended to put in main loop of the program, but it is not critical.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ShutdownHandler.TryRegisterCallback(System.Action,Gemstone.Diagnostics.ShutdownHandlerOrder)">
            <summary>
            Attempts Registers a callback that will be called
            when the application is shutdown.
            </summary>
            <param name="callback">the callback when the shutdown occurs</param>
            <param name="shutdownOrder">the order that the callback will occur.</param>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Diagnostics.ShutdownHandler.InitiateSafeShutdown">
            <summary>
            Requests that certain components initiate a safe shutdown.
            </summary>
            <remarks>
            This method should only be called when the main thread exits. Calling this outside
            of the application exiting could result in unpredictable behavior.
            </remarks>
        </member>
        <member name="T:Gemstone.Diagnostics.SystemPerformanceMonitor">
            <summary>
            Represents a system performance monitor for system level performance statistics, e.g.,
            CPU utilization and available memory.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.SystemPerformanceMonitor.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Gemstone.Diagnostics.SystemPerformanceMonitor"/>.
            </summary>
            <param name="samplingInterval">
            Interval, in milliseconds, at which the <see cref="P:Gemstone.Diagnostics.PerformanceMonitorBase.Counters"/>
            are to be sampled.
            </param>
            <remarks>
            It is recommended to use the <see cref="P:Gemstone.Diagnostics.SystemPerformanceMonitor.Default"/> instance of this class
            instead of creating a new instance where applicable.
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.SystemPerformanceMonitor.CPUUsage">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the processor utilization of the system.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.SystemPerformanceMonitor.AvailableMemory">
            <summary>
            Gets the <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> that monitors the remaining available memory of the system in GB.
            </summary>
            <remarks>This <see cref="T:Gemstone.Diagnostics.PerformanceCounter"/> is added by default.</remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.SystemPerformanceMonitor.Default">
            <summary>
            Gets default reference of <see cref="T:Gemstone.Diagnostics.SystemPerformanceMonitor"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.ThreadPoolTrace">
            <summary>
            Executes a trace on the <see cref="T:System.Threading.ThreadPool"/> for all callbacks currently queued.
            This will not include work items that have a time delayed callback.
            </summary>
            <remarks>
            This class heavily relies on reflection to get the ThreadPool queue.
            Therefore it is very unlikely to work in MONO and can break 
            if Microsoft changes any of the member names or how the ThreadPool 
            works.
            
            In this case <see cref="P:Gemstone.Diagnostics.ThreadPoolTrace.WorksInThisRuntime"/> will be set to false
            and <see cref="M:Gemstone.Diagnostics.ThreadPoolTrace.GetTrace(System.Text.StringBuilder)"/> will return "Not Supported"
            
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.ThreadPoolTrace.WorksInThisRuntime">
            <summary>
            Indicates that this trace works in the runtime version of .NET.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.ThreadPoolTrace.GetTrace(System.Text.StringBuilder)">
            <summary>
            Traces all queued items on the ThreadPool.
            </summary>
            <param name="sb"></param>
        </member>
        <member name="T:Gemstone.Diagnostics.TimerTrace">
            <summary>
            Executes a trace on the <see cref="T:System.Threading.Timer"/> for all queued timers.
            </summary>
            <remarks>
            This class heavily relies on reflection to get the Timer queue.
            Therefore it is very unlikely to work in MONO and can break 
            if Microsoft changes any of the member names or how the Timer 
            works.
            
            In this case <see cref="P:Gemstone.Diagnostics.TimerTrace.WorksInThisRuntime"/> will be set to false
            and <see cref="M:Gemstone.Diagnostics.TimerTrace.GetTrace(System.Text.StringBuilder)"/> will return "Not Supported"
            
            </remarks>
        </member>
        <member name="P:Gemstone.Diagnostics.TimerTrace.WorksInThisRuntime">
            <summary>
            Indicates that this trace works in the runtime version of .NET.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.TimerTrace.GetTrace(System.Text.StringBuilder)">
            <summary>
            Gets all of the callbacks for all timers.
            </summary>
            <param name="sb"></param>
        </member>
        <member name="T:Gemstone.Diagnostics.Utilities.LogFileCompactor">
            <summary>
            A method to read all of the logs in a single file.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogFileCompactor.Compact(System.Collections.Generic.ICollection{System.String},System.String)">
            <summary>
            Reads all log messages from the supplied file.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Utilities.LogFileReader">
            <summary>
            A method to read all of the logs in a single file.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogFileReader.Read(System.String)">
            <summary>
            Reads all log messages from the supplied file.
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Utilities.LogFileWriter">
            <summary>
            A log subscriber that will log messages to a file.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.Utilities.LogFileWriter.FileName">
            <summary>
            The file name
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogFileWriter.#ctor(System.String)">
            <summary>
            Creates a LogFileWriter that initially queues message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Utilities.LogFileWriter.LogCount">
            <summary>
            The number of logs that have been written to this file.
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Utilities.LogFileWriter.LogSize">
            <summary>
            The current size of the log file.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogFileWriter.Write(Gemstone.Diagnostics.LogMessage,System.Boolean)">
            <summary>
            Writes the specified log to the file
            </summary>
            <param name="log"></param>
            <param name="autoFlush"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogFileWriter.Flush">
            <summary>
            Flushes the stream to the disk.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogFileWriter.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Gemstone.Diagnostics.Utilities.LogSubscriptionConsole">
            <summary>
            Creates a <see cref="T:Gemstone.Diagnostics.LogSubscriber"/> that will write messages to the <see cref="N:Gemstone.Console"/>
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogSubscriptionConsole.#ctor">
            <summary>
            Creates a LogFileWriter that initially queues message
            </summary>
        </member>
        <member name="P:Gemstone.Diagnostics.Utilities.LogSubscriptionConsole.Verbose">
            <summary>
            Gets or sets verbosity level for this <see cref="T:Gemstone.Diagnostics.Utilities.LogSubscriptionConsole"/>.
            To disable the console from receiving messages, set to <see cref="F:Gemstone.Diagnostics.VerboseLevel.None"/>
            </summary>
        </member>
        <member name="T:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter">
            <summary>
            A log subscription that will write messages to a file
            </summary>
        </member>
        <member name="E:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.NewFileComplete">
            <summary>
            When a new file has been completed.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.#ctor(System.Int32)">
            <summary>
            Creates a LogFileWriter that initially queues message
            </summary>
            <param name="messageLimit">the number of messages to maintain</param>
        </member>
        <member name="P:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.Verbose">
            <summary>
            Gets or sets verbosity level for this <see cref="T:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.SetLoggingFileCount(System.Int32)">
            <summary>
            Sets the maximum number of log files before a new one will delete the oldest one.
            </summary>
            <param name="maxFileCount"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.SetPath(System.String)">
            <summary>
            Sets the path of the log files.
            </summary>
            <param name="logDirectory"></param>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.SetPath(System.String,Gemstone.Diagnostics.VerboseLevel)">
            <summary>
            Sets log file writer path and optionally its verbosity level.
            </summary>
        </member>
        <member name="M:Gemstone.Diagnostics.Utilities.LogSubscriptionFileWriter.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Gemstone.Diagnostics.VerboseLevel">
            <summary>
            General Verbose Levels exposed to the user for application logging.
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.VerboseLevel.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.VerboseLevel.Low">
            <summary>
            Component=Error, Framework=Error, Application=Warning
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.VerboseLevel.Medium">
            <summary>
            Component=Warning, Framework=Warning, Application=Info
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.VerboseLevel.High">
            <summary>
            Component=Info, Framework=Info, Application=Debug
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.VerboseLevel.Ultra">
            <summary>
            Component=Debug, Framework=Debug, Application=Debug
            </summary>
        </member>
        <member name="F:Gemstone.Diagnostics.VerboseLevel.All">
            <summary>
            Component=Debug, Framework=Debug, Application=Debug, Include Suppressed Logs.
            </summary>
        </member>
    </members>
</doc>
