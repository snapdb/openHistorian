<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Gemstone.Threading</name>
    </assembly>
    <members>
        <member name="T:Gemstone.Threading.AsyncLock">
            <summary>
            Represents a lock that can be awaited to obtain exclusive
            access to resources within a critical region of code.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync">
            <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
            <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose"/>.
            </returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The lock could not be taken.</exception>
        </member>
        <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.Int32)">
            <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
            <param name="milliseconds">The number of milliseconds to wait before failing to take the lock.</param>
            <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose"/>.
            </returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The timeout expires before the lock could be taken.</exception>
        </member>
        <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.TimeSpan)">
            <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
            <param name="timeout">The amount of time to wait before failing to take the lock.</param>
            <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose"/>.
            </returns>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">The <paramref name="timeout"/> expires before the lock could be taken.</exception>
            <remarks>
            <para>
            The following illustrates an example of using try-catch to detect a failure to take the lock.
            </para>
            
            <code>
            AsyncLock asyncLock = new AsyncLock();
            
            try
            {
                using IDisposable token = await asyncLock.TryEnterAsync();
                // Critical region
            }
            catch (TaskCanceledException)
            {
                // Lock failed
            }
            </code>
            
            <para>
            The following illustrates an example of using <see cref="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})"/>
            to detect a failure to take the lock.
            </para>
            
            <code>
            AsyncLock asyncLock = new AsyncLock();
            
            await asyncLock.TryEnterAsync().ContinueWith(async tokenTask =>
            {
                if (tokenTask.IsCanceled)
                {
                    // Lock failed
                    return;
                }
            
                using IDisposable token = await tokenTask;
                // Critical region
            }).Unwrap();
            </code>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.AsyncLock.EnterAsync">
            <summary>
            Obtains exclusive access to the lock.
            </summary>
            <returns>
            A task that must be awaited to obtain the token that will
            release the lock on <see cref="M:System.IDisposable.Dispose"/>.
            </returns>
        </member>
        <member name="T:Gemstone.Threading.AsyncReaderWriterLock">
            <summary>
            Represents an asynchronous implementation of a reader/writer lock.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.Int32)">
            <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
            <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
            <returns>The token used to control the duration of entry.</returns>
            <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
        </member>
        <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.TimeSpan)">
            <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
            <param name="timeout">The amount of time to wait before timing out.</param>
            <returns>The token used to control the duration of entry.</returns>
            <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout"/> expired.</exception>
        </member>
        <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.Int32)">
            <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
            <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
            <returns>The token used to control the duration of entry.</returns>
            <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
        </member>
        <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.TimeSpan)">
            <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
            <param name="timeout">The amount of time to wait before timing out.</param>
            <returns>The token used to control the duration of entry.</returns>
            <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout"/> expired.</exception>
        </member>
        <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterReadAsync">
            <summary>
            Enters the lock with concurrent access where all readers
            can execute concurrently with respect to each other.
            </summary>
            <returns>The token used to control the duration of entry.</returns>
        </member>
        <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterWriteAsync">
            <summary>
            Enters the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
            <returns>The token used to control the duration of entry.</returns>
        </member>
        <member name="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1">
            <summary>
            Combines <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1"/> and <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1"/> to provide
            a low-contention, double-buffered queue suitable for multiple-producer, single-consumer
            scenarios.
            </summary>
            <typeparam name="T">Type of items being queued.</typeparam>
        </member>
        <member name="E:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessException">
            <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1"/>.
            </summary>
            <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1"/> class.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessItemsFunction">
            <summary>
            Gets or sets item processing function.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Count">
            <summary>
            Gets the number of items in the queue.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Enqueues a collection of items into the async double-buffered queue.
            </summary>
            <param name="items">The items to be queued.</param>
        </member>
        <member name="T:Gemstone.Threading.Collections.AsyncQueue`1">
            <summary>
            Creates a fast, light-weight asynchronous processing queue with very low contention.
            </summary>
            <typeparam name="T">Type of items to process.</typeparam>
        </member>
        <member name="E:Gemstone.Threading.Collections.AsyncQueue`1.ProcessException">
            <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1"/>.
            </summary>
            <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor">
            <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType)">
            <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1"/>.
            </summary>
            <param name="synchronizedOperationType">The type of synchronized operation to use to process items in the queue.</param>
        </member>
        <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Count">
            <summary>
            Gets the total number of items currently in the queue.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.ProcessItemFunction">
            <summary>
            Gets or sets item processing function.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Enabled">
            <summary>
            Gets or sets flag that enables or disables processing.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Enqueues an item for processing.
            </summary>
            <param name="item">Item to be queued for processing.</param>
        </member>
        <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1">
            <summary>
            A thread-safe double-buffered queue that allows for low-contention
            item processing in single-producer, single-consumer scenarios.
            </summary>
            <typeparam name="T">Type of items being queued.</typeparam>
            <remarks>
            It is not safe to use this class with multiple consumer threads.
            The <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue"/> method must be called by one thread at
            a time, and the consumer must not access a list returned by Dequeue
            after its next call to Dequeue.
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessException">
            <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1"/>.
            </summary>
            <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1"/> class.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessItemsFunction">
            <summary>
            Gets or sets item processing function.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Count">
            <summary>
            Gets the current number of items in the queue.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Enqueues a collection of items into the double-buffered queue.
            </summary>
            <param name="items">The collection of items to be enqueued.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue">
            <summary>
            Dequeues a collection of items from the queue.
            </summary>
            <returns>
            A collection of items that have previously been enqueued,
            or no items if none have been enqueued since last dequeue.
            </returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Clear">
            <summary>
            Empties the producer's buffer so that the
            items can no longer be consumed by the consumer.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryEnqueue(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
            <param name="items">The collection of items to be enqueued.</param>
            <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryDequeue(System.Collections.Generic.IList{`0}@)">
            <summary>
            Attempts to dequeue a collection of items from the queue and
            returns the number of items left in the queue after dequeuing.
            </summary>
            <param name="items">The items that were dequeued.</param>
            <returns>
            The number of items left in the queue after
            dequeuing as many items as possible.
            </returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryClear">
            <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
            <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
        </member>
        <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1">
            <summary>
            A producer for a <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1"/> which can
            only be used to provide items to the queue for consumption.
            </summary>
            <typeparam name="T">The type of the items produced to the queue.</typeparam>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.#ctor(Gemstone.Threading.Collections.DoubleBufferedQueueManager{`0},Gemstone.Threading.Collections.DoubleBufferedQueue{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/> class.
            </summary>
            <param name="manager">The <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/> that created this producer.</param>
            <param name="queue">The <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1"/> that this producer will be producing to.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Produce(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Produces a collection of items to be processed by the consumer.
            </summary>
            <param name="items">The collection of items to be enqueued.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1">
            <summary>
            Manages queues to reduce contention for a multi-threaded, multiple-producer, single-consumer scenario.
            </summary>
            <remarks>
            For best results, each thread that is producing items to the consumer should call
            <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer"/> to receive a producer object that will not contend with
            any other producer. The consumer should either provide a handler to process the queued
            items or poll the manager by calling <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue"/> (not both!). It is not
            safe to use this class with multiple consumer threads.
            </remarks>
            <typeparam name="T">The types of items to be queued.</typeparam>
            <remarks>
            It is not safe to use this class with multiple consumer threads.
            The list returned by <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue"/> is not thread-safe and
            is reused on each Dequeue operation, so no other thread should
            access the list while another thread is calling Dequeue.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/> class.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/> class.
            </summary>
            <param name="itemHandler">The method to handle processing of queued items.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/> class.
            </summary>
            <param name="itemHandler">The method to handle processing of queued items.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/> class.
            </summary>
            <param name="itemHandler">The method to handle processing of queued items.</param>
            <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}},System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/> class.
            </summary>
            <param name="itemHandler">The method to handle processing of queued items.</param>
            <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
        </member>
        <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.ItemsLeft">
            <summary>
            Gets a flag that indicates whether there are any items left to
            be consumed after the last call to <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer">
            <summary>
            Creates a producer used to produce items to the consumer of this <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/>.
            </summary>
            <returns>A <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/> used to produce items to the consumer.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue">
            <summary>
            Dequeues a list of items produced by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/>s.
            </summary>
            <returns>A list of items to be consumed.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.SignalItemHandler">
            <summary>
            Runs the operation to process items produced by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1"/>s.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.ReturnQueue(Gemstone.Threading.Collections.DoubleBufferedQueue{`0})">
            <summary>
            Returns a queue to the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1"/>
            so that it can be removed from the list of queues to be consumed.
            </summary>
            <param name="queue">The queue to be returned.</param>
        </member>
        <member name="T:Gemstone.Threading.Collections.NamespaceDoc">
            <summary>
            The <see cref="N:Gemstone.Threading.Collections"/> namespace provides classes for collections related
            to threading functionality, e.g., <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.Collections.PriorityQueue`1">
            <summary>
            Represents a thread-safe prioritized first in-first out (FIFO) collection.
            </summary>
            <typeparam name="T">The type of elements contained in the queue.</typeparam>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> class.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> class.
            </summary>
            <param name="priorityLevels">The number of priority levels to preallocate in the queue.</param>
            <exception cref="T:System.ArgumentException"><paramref name="priorityLevels"/> is less than or equal to 0.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(Gemstone.Threading.Collections.PriorityQueue{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> class.
            </summary>
            <param name="priorityQueue">Another priority queue of items to be enqueued in this queue at the same priority.</param>
            <exception cref="T:System.ArgumentException"><paramref name="priorityQueue"/> queue length is less than or equal to 0.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="priorityQueue"/> is <c>null</c>.</exception>
        </member>
        <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.Count">
            <summary>
            Gets the number of items in the queue.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.IsEmpty">
            <summary>
            Indicates whether the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> is empty.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.Enqueue(`0,System.Int32)">
            <summary>
            Enqueues an item into the priority queue.
            </summary>
            <param name="item">The item to be enqueued.</param>
            <param name="priority">The priority at which the item should be queued. Larger numbers have higher priority!</param>
            <exception cref="T:System.ArgumentException"><paramref name="priority"/> is negative</exception>
            <remarks>
            This priority queue is implemented using an array of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            The array index indicates the priority of tasks in each queue. For best performance,
            ensure that your code defines all priority levels consecutively, starting from 0.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(System.Int32,`0@)">
            <summary>
            Dequeues an item from the priority queue.
            </summary>
            <param name="priority">The priority at which the item should be dequeued.</param>
            <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
            <returns>True if an item was dequeued; false if the queue is empty.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(`0@)">
            <summary>
            Dequeues an item from the priority queue.
            </summary>
            <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
            <returns>True if an item was dequeued; false if the queue is empty.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(System.Int32,`0@)">
            <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> without removing it.
            </summary>
            <param name="priority">The priority at which to peek into the queue.</param>
            <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> or an unspecified value if the operation failed.
            </param>
            <returns>true if an object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(`0@)">
            <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> without removing it.
            </summary>
            <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> or an unspecified value if the operation failed.
            </param>
            <returns>true if an object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> elements to an existing
            one-dimensional <see cref="T:System.Array"/>, starting at the specified array index.
            </summary>
            <param name="array">
            The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied
            from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/>. The <see cref="T:System.Array"/> must
            have zero-based indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">array is a null reference (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero.</exception>
            <exception cref="T:System.ArgumentException">
            index is equal to or greater than the length of the array -or- The number of
            elements in the source <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> is greater
            than the available space from index to the end of the destination array.
            </exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/>.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.ToArray">
            <summary>
            Copies the elements stored in the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1"/>.</returns>
        </member>
        <member name="T:Gemstone.Threading.Collections.QueueThreadingMode">
            <summary>
            Enumeration of possible <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> threading modes.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.QueueThreadingMode.Asynchronous">
            <summary>
            Processes several items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> at once on different threads, where processing order is not important.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.QueueThreadingMode.Synchronous">
            <summary>
            Processes items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> one at a time on a single thread, where processing order is important.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.Collections.QueueProcessingStyle">
            <summary>
            Enumeration of possible <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> processing styles.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.QueueProcessingStyle.OneAtATime">
            <summary>
            Defines <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> processing delegate to process only one item at a time.
            </summary>
            <remarks>
            This is the typical <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle"/> when the <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode"/> is asynchronous.
            </remarks>
        </member>
        <member name="F:Gemstone.Threading.Collections.QueueProcessingStyle.ManyAtOnce">
            <summary>
            Defines <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> processing delegate to process all currently available items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            Items are passed into delegate as an array.
            </summary>
            <remarks>
            This is the optimal <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle"/> when the <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode"/> is synchronous.
            </remarks>
        </member>
        <member name="T:Gemstone.Threading.Collections.RequeueReason">
            <summary>
            Enumeration of possible requeue reasons.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.RequeueReason.CannotProcess">
            <summary>
            Requeuing item since it cannot be processed at this time.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.RequeueReason.Exception">
            <summary>
            Requeuing item due to an exception.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.RequeueReason.Timeout">
            <summary>
            Requeuing item due to timeout.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.Collections.RequeueMode">
            <summary>
            Enumeration of possible requeue modes.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.RequeueMode.Prefix">
            <summary>
            Requeues item at the beginning of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.RequeueMode.Suffix">
            <summary>
            Requeues item at the end of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.Collections.ProcessQueue`1">
            <summary>
            Represents a thread-safe (via locking) list of items, based on <see cref="T:System.Collections.Generic.List`1"/>, that get processed on independent threads with a consumer provided function.
            </summary>
            <typeparam name="T">Type of object to process</typeparam>
            <remarks>
            <para>This class acts as a strongly-typed collection of objects to be processed.</para>
            <para>Note that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> will not start processing until the Start method is called.</para>
            </remarks>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultProcessInterval">
            <summary>
            Default processing interval (in milliseconds).
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultMaximumThreads">
            <summary>
            Default maximum number of processing threads.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultProcessTimeout">
            <summary>
            Default processing timeout (in milliseconds).
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueOnTimeout">
            <summary>
            Default setting for requeuing items on processing timeout.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueOnException">
            <summary>
            Default setting for requeuing items on processing exceptions.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.RealTimeProcessInterval">
            <summary>
            Default real-time processing interval (in milliseconds).
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueModeOnTimeout">
            <summary>
            Default setting for requeuing mode on processing timeout.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueue`1.DefaultRequeueModeOnException">
            <summary>
            Default setting for requeuing mode on processing exceptions.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunctionSignature">
            <summary>
            Function signature that defines a method to process items one at a time.
            </summary>
            <param name="item">Item to be processed.</param>
            <remarks>
            <para>Required unless <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/> is implemented.</para>
            <para>Creates an asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> to process individual items - one item at a time - on multiple threads.</para>
            </remarks>
        </member>
        <member name="T:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunctionSignature">
            <summary>
            Function signature that defines a method to process multiple items at once.
            </summary>
            <param name="items">Items to be processed.</param>
            <remarks>
            <para>Required unless <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> is implemented.</para>
            <para>Creates an asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> to process groups of items simultaneously on multiple threads.</para>
            </remarks>
        </member>
        <member name="T:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItemFunctionSignature">
            <summary>
            Function signature that determines if an item can be currently processed.
            </summary>
            <param name="item">Item to be checked for processing availability.</param>
            <returns>True, if item can be processed. The default is true.</returns>
            <remarks>
            <para>Implementation of this function is optional. It is assumed that an item can be processed if this
            function is not defined</para>
            <para>Items must eventually get to a state where they can be processed, or they will remain in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>
            indefinitely.</para>
            <para>
            Note that when this function is implemented and ProcessingStyle = ManyAtOnce (i.e., 
            <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/> is defined), then each item presented for 
            processing must evaluate as "CanProcessItem = True" before any items are processed.
            </para>
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemProcessed">
            <summary>
            Event that is raised after an item has been successfully processed.
            </summary>
            <remarks>
            <para>Allows custom handling of successfully processed items.</para>
            <para>Allows notification when an item has completed processing in the allowed amount of time, if a process
            timeout is specified.</para>
            <para>Raised only when ProcessingStyle = OneAtATime (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> is defined).</para>
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsProcessed">
            <summary>
            Event that is raised after an array of items have been successfully processed.
            </summary>
            <remarks>
            <para>Allows custom handling of successfully processed items.</para>
            <para>Allows notification when an item has completed processing in the allowed amount of time, if a process
            timeout is specified.</para>
            <para>Raised only when when ProcessingStyle = ManyAtOnce (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/> is defined).</para>
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemTimedOut">
            <summary>
            Event that is raised if an item's processing time exceeds the specified process timeout.
            </summary>
            <remarks>
            <para>Allows custom handling of items that took too long to process.</para>
            <para>Raised only when ProcessingStyle = OneAtATime (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> is defined).</para>
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsTimedOut">
            <summary>
            Event that is raised if the processing time for an array of items exceeds the specified process timeout.
            </summary>
            <remarks>
            <para>Allows custom handling of items that took too long to process.</para>
            <para>Raised only when ProcessingStyle = ManyAtOnce (i.e., <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/> is defined).</para>
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.ProcessException">
            <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <remarks>
            Processing will not stop for any exceptions thrown by the user function, but any captured exceptions will
            be exposed through this event.
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.Collections.ProcessQueue`1.Disposed">
            <summary>
            Occurs when the class has been disposed.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> based on the generic List(Of T) class.
            </summary>
            <param name="processItemFunction">Delegate that defines a method to process one item at a time.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> based on the generic List(Of T) class.
            </summary>
            <param name="processItemFunction">Delegate that defines a method to process one item at a time.</param>
            <param name="canProcessItemFunction">Delegate that determines if an item can currently be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> based on the generic List(Of T) class.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> based on the generic List(Of T) class.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate that determines if an item can currently be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.#ctor(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Collections.Generic.IList{`0},System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Allows derived classes to define their own instance, if desired.
            </summary>
            <param name="processItemFunction">Delegate that defines a method to process one item at a time.</param>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate that determines if an item can currently be processed.</param>
            <param name="processList">A storage list for items to be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">The maximum number of threads for the queue to use.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <returns>The element at the specified index.</returns>
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is equal to or greater than <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> length.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <param name="item">When this method returns, if the object was removed and returned successfully, item contains the removed object. If no object was available to be removed, the value is unspecified.</param>
            <returns><c>true</c> if an object was removed and returned successfully; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.TryTake(`0[]@)">
            <summary>
            Attempts to remove and return all objects from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <param name="items">When this method returns, if any objects were removed and returned successfully, item array contains the removed objects. If no object was available to be removed, the value is null.</param>
            <returns><c>true</c> if any objects were removed and returned successfully; otherwise, <c>false</c>.</returns>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsReadOnly">
            <summary>Gets a value indicating whether the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is read-only.</summary>
            <returns>True, if the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is read-only; otherwise, false. In the default implementation, this property
            always returns false.</returns>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction">
            <summary>
            Gets or sets the user function for processing individual items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> one at a time.
            </summary>
            <remarks>
            <para>Cannot be defined simultaneously with <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/>.</para>
            <para>A <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> must be defined to process a single item at a time or many items at once.</para>
            <para>Implementation makes ProcessingStyle = OneAtATime.</para>
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction">
            <summary>
            Gets or sets the user function for processing multiple items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> at once.
            </summary>
            <remarks>
            <para>This function and <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> cannot be defined at the same time</para>
            <para>A <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> must be defined to process a single item at a time or many items at once</para>
            <para>Implementation of this function makes ProcessingStyle = ManyAtOnce</para>
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItemFunction">
            <summary>
            Gets or sets the user function determining if an item is ready to be processed.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessingIsRealTime">
            <summary>
            Gets indicator that items will be processed in real-time.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ThreadingMode">
            <summary>
            Gets the current <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode"/> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., synchronous or asynchronous).
            </summary>
            <remarks>
            <para>The maximum number of processing threads determines the <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode"/>.</para>
            <para>If the maximum threads are set to one, item processing will be synchronous
            (i.e., ThreadingMode = Synchronous).</para>
            <para>If the maximum threads are more than one, item processing will be asynchronous
            (i.e., ThreadingMode = Asynchronous).</para>
            <para>
            Note that for asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, the processing interval will control how many threads are spawned
            at once. If items are processed faster than the specified processing interval, only one process thread
            will ever be spawned at a time. To ensure multiple threads are utilized to <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> items, lower
            the process interval (minimum process interval is 1 millisecond).
            </para>
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessingStyle">
            <summary>
            Gets the item <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle"/> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., one at a time or many at once).
            </summary>
            <returns>
            <para>OneAtATime, if the <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> is implemented.</para>
            <para>ManyAtOnce, if the <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/> is implemented.</para>
            </returns>
            <remarks>
            <para>The implemented item processing function determines the <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle"/>.</para>
            <para>
            If the <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle"/> is ManyAtOnce, all available items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> are presented for processing
            at each processing interval. If you expect items to be processed in the order in which they were received, make
            sure you use a synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. Real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> are inherently synchronous.
            </para>
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessInterval">
            <summary>
            Gets or sets the interval, in milliseconds, on which new items begin processing.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.MaximumThreads">
            <summary>
            Gets or sets the maximum number of threads to process simultaneously.
            </summary>
            <value>Sets the maximum number of processing threads.</value>
            <returns>Maximum number of processing threads.</returns>
            <remarks>If MaximumThreads is set to one, item processing will be synchronous (i.e., ThreadingMode = Synchronous)</remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessTimeout">
            <summary>
            Gets or sets the maximum time, in milliseconds, allowed for processing an item.
            </summary>
            <value>Sets the maximum number of milliseconds allowed to process an item.</value>
            <returns>The maximum number of milliseconds allowed to process an item.</returns>
            <remarks>Set to Timeout.Infinite (i.e., -1) to allow processing to take as long as needed.</remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.SynchronizedOperationType">
            <summary>
            Gets or sets the type of synchronized operation used to process items in a real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueOnTimeout">
            <summary>
            Gets or sets whether or not to automatically place an item back into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> if the processing times out.
            </summary>
            <remarks>Ignored if the ProcessTimeout is set to Timeout.Infinite (i.e., -1).</remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueOnException">
            <summary>
            Gets or sets whether or not to automatically place an item back into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> if an exception occurs
            while processing.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueModeOnTimeout">
            <summary>
            Gets or sets the mode of insertion used (prefix or suffix) when at item is placed back into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>
            after processing times out.
            </summary>
            <remarks>Only relevant when RequeueOnTimeout = True.</remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RequeueModeOnException">
            <summary>
            Gets or sets the mode of insertion used (prefix or suffix) when at item is placed back into the
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> after an exception occurs while processing.
            </summary>
            <remarks>Only relevant when RequeueOnException = True.</remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Enabled">
            <summary>
            Gets or sets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is currently enabled.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsDisposed">
            <summary>
            Gets a flag that indicates whether the object has been disposed.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsProcessing">
            <summary>
            Gets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is actively processing items.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is empty.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ItemsBeingProcessed">
            <summary>
            Gets the total number of items currently being processed.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.TotalProcessedItems">
            <summary>
            Gets the total number of items processed so far.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.TotalFunctionCalls">
            <summary>
            Gets the total number of calls to <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> or <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.ThreadCount">
            <summary>
            Gets the current number of active threads.
            </summary>
            <returns>Current number of active threads.</returns>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.RunTime">
            <summary>
            Gets the total amount of time, in seconds, that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> has been active.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Name">
            <summary>
            Gets or sets name for this <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <remarks>
            This name is used for class identification in strings (e.g., used in error messages).
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Count">
            <summary>Gets the number of elements actually contained in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>The number of elements actually contained in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.IsSynchronized">
            <summary>Gets a value indicating whether access to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is synchronized (thread safe).  Always returns true for <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>true, <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is always synchronized (thread safe).</returns>
            <remarks>The <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is effectively "synchronized" since all functions SyncLock operations internally.</remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.CancellationToken">
            <summary>
            Gets the per processing thread cancellation token to check when a <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessTimeout"/> is specified.
            </summary>
            <remarks>
            This token should be checked in the user implemented <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemFunction"/> or <see cref="P:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItemsFunction"/> to
            determine if a timeout has occurred so that the code can cleanly exit.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.CurrentStatistics">
            <summary>
            Gets the current run-time statistics of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> as a single group of values.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.Status">
            <summary>
            Gets current status of <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.InternalEnumerable">
            <summary>
            Allows derived classes to access the interfaced internal <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> directly.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. 
            </summary>
        </member>
        <member name="P:Gemstone.Threading.Collections.ProcessQueue`1.InternalList">
            <summary>
            Gets the internal list for direct use by <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.SignalDataModified">
            <summary>
            Manually signals that data has been modified and processing should resume.
            </summary>
            <remarks>
            This function should be called in cases where a user may need to signal data modification. For example,
            if <typeparamref name="T"/> was a dictionary or list that was updated - you would need to manually
            signal that data had changed in this item.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Contains(`0)">
            <summary>
            Determines whether an element is in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <returns>True, if item is found in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>; otherwise, false.</returns>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ToArray">
            <summary>
            Copies the elements contained in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> to a new array. 
            </summary>
            <returns>A new array containing the elements copied from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <returns>An enumerator for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Start">
            <summary>
            Starts item processing.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Stop">
            <summary>
            Stops item processing.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Flush">
            <summary>
            Blocks the current thread, if the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is active (i.e., user has called "Start" method), until all items
            in <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> are processed, and then stops the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <remarks>
            <para>
            Begins processing items as quickly as possible, regardless of currently defined process interval, until all
            items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> have been processed. Stops the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> when this function ends.
            This method is typically called on shutdown to make sure any remaining queued items get processed before the
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is destructed.
            </para>
            <para>
            It is possible for items to be added to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> while the flush is executing. The flush will continue to
            process items as quickly as possible until the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is empty. Unless the user stops queuing items to be
            processed, the flush call may never return (not a happy situation on shutdown). For this reason, during this
            function call, requeuing of items on exception or process timeout is temporarily disabled.
            </para>
            <para>
            The <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> does not clear queue prior to destruction. If the user fails to call this method before the
            class is destructed, there may be items that remain unprocessed in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemProcessed(`0)">
            <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemProcessed"/> event.
            </summary>
            <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
            <param name="item">A generic type T to be passed to ItemProcessed.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemsProcessed(`0[])">
            <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsProcessed"/> event.
            </summary>
            <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
            <param name="items">An array of generic type T to be passed to ItemsProcessed.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemTimedOut(`0)">
            <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemTimedOut"/> event.
            </summary>
            <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
            <param name="item">A generic type T to be passed to ItemProcessed.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnItemsTimedOut(`0[])">
            <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ItemsTimedOut"/> event.
            </summary>
            <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
            <param name="items">An array of generic type T to be passed to ItemsProcessed.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.OnProcessException(System.Exception)">
            <summary>
            Raises the base class <see cref="E:Gemstone.Threading.Collections.ProcessQueue`1.ProcessException"/> event.
            </summary>
            <remarks>
            Derived classes cannot raise events of their base classes, so we expose event wrapper methods to accommodate
            as needed.
            </remarks>
            <param name="ex"><see cref="T:System.Exception"/> to be passed to ProcessException.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.DataAdded">
            <summary>
            Notifies queue that data was added and/or modified, so it can begin processing data.
            </summary>
            <remarks>
            <para>
            Derived classes *must* make sure to call this method after data gets added, so that the
            process timer can be enabled for intervaled <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> and data processing can begin.
            </para>
            <para>
            To make sure items in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> always get processed, this function is expected to be
            invoked from within a SyncLock of the exposed SyncRoot (i.e., InternalList).
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItem(`0)">
            <summary>
            Determines if an item can be processed.
            </summary>
            <values>True, if user provided no implementation for the CanProcessItemFunction.</values>
            <remarks>
            <para>
            Use this function instead of invoking the CanProcessItemFunction pointer
            directly, since implementation of this delegate is optional.
            </para>
            </remarks>
            <param name="item">The item T to process.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether it can process the item or not.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CanProcessItems(`0[])">
            <summary>
            Determines if all items can be processed.
            </summary>
            <values>True, if user provided no implementation for the CanProcessItemFunction.</values>
            <remarks>
            <para>
            Use this function instead of invoking the CanProcessItemFunction pointer
            directly, since implementation of this delegate is optional.
            </para>
            </remarks>
            <param name="items">An array of items of type T.</param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the process queue can process the items.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RequeueItem(`0,Gemstone.Threading.Collections.RequeueReason)">
            <summary>
            Requeues item into <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> according to specified requeue reason.
            </summary>
            <param name="item">A generic item of type T to be requeued.</param>
            <param name="reason">The reason the object is being requeued.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RequeueItems(`0[],Gemstone.Threading.Collections.RequeueReason)">
            <summary>
            Requeues items into <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> according to specified requeue reason.
            </summary>
            <param name="items">Array of type T to be requeued.</param>
            <param name="reason">The reason the object is being requeued.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the specified collection to the end of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
            <param name="collection">
            The collection whose elements should be added to the end of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            The collection itself cannot be null, but it can contain elements that are null, if type T is a reference type.
            </param>
            <exception cref="T:System.ArgumentNullException">collection is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.BinarySearch(`0)">
            <summary>
            Searches the entire sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using a binary search algorithm, for an element using the
            default comparer and returns the zero-based index of the element.
            </summary>
            <remarks>
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> must be sorted in order for this function to return an accurate result.
            </remarks>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, if item is found; otherwise, a negative number that is the
            bitwise complement of the index of the next element that is larger than item or, if there is no larger element,
            the bitwise complement of count.
            </returns>
            <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches the entire sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using a binary search algorithm, for an element using the
            specified comparer and returns the zero-based index of the element.
            </summary>
            <remarks>
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> must be sorted in order for this function to return an accurate result.
            </remarks>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The Generic.IComparer implementation to use when comparing elements -or-
            null to use the default comparer: Generic.Comparer(Of T).Default</param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, if item is found; otherwise, a negative number that is the
            bitwise complement of the index of the next element that is larger than item or, if there is no larger element,
            the bitwise complement of count.
            </returns>
            <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Searches a range of elements in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using a binary search algorithm, for an
            element using the specified comparer and returns the zero-based index of the element.
            </summary>
            <remarks>
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> must be sorted in order for this function to return an accurate result.
            </remarks>
            <param name="index">The zero-based starting index of the range to search.</param>
            <param name="count">The length of the range to search.</param>
            <param name="item">The object to locate. The value can be null for reference types.</param>
            <param name="comparer">The Generic.IComparer implementation to use when comparing elements -or- null to use
            the default comparer: Generic.Comparer(Of T).Default</param>
            <returns>
            The zero-based index of item in the sorted <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, if item is found; otherwise, a negative number that is the
            bitwise complement of the index of the next element that is larger than item or, if there is no larger element,
            the bitwise complement of count.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>
            -or- count is less than 0 -or- startIndex and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/></exception>
            <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ConvertAll``1(System.Converter{`0,``0})">
            <summary>Converts the elements in the current <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> to another type, and returns a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> containing the
            converted elements.</summary>
            <returns>A generic list of the target type containing the converted elements from the current <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
            <param name="converter">A Converter delegate that converts each element from one type to another type.</param>
            <exception cref="T:System.ArgumentNullException">converter is null.</exception>
            <typeparam name="TOutput">The generic type used.</typeparam>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Exists(System.Predicate{`0})">
            <summary>Determines whether the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> contains elements that match the conditions defined by the specified
            predicate.</summary>
            <returns>True, if the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> contains one or more elements that match the conditions defined by the specified
            predicate; otherwise, false.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the elements to search for.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Find(System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the first occurrence within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>The first element that matches the conditions defined by the specified predicate, if found;
            otherwise, the default value for type T.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindAll(System.Predicate{`0})">
            <summary>Retrieves all elements that match the conditions defined by the specified predicate.</summary>
            <returns>A generic list containing all elements that match the conditions defined by the specified predicate,
            if found; otherwise, an empty list.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the elements to search for.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindIndex(System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the first occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that extends from the
            specified index to the last element.</summary>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by
            match, if found; otherwise, 1.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindIndex(System.Int32,System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the first occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that extends from the
            specified index to the last element.</summary>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by
            match, if found; otherwise, 1.</returns>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the first occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that extends from the
            specified index to the last element.</summary>
            <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by
            match, if found; otherwise, 1.</returns>
            <param name="startIndex">The zero-based starting index of the search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>
            -or- count is less than 0 -or- startIndex and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLast(System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type T.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLastIndex(System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the last occurrence within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by
            match, if found; otherwise, 1.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the last occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that extends from the
            first element to the specified index.</summary>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by
            match, if found; otherwise, 1.</returns>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns
            the zero-based index of the last occurrence within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that contains the
            specified number of elements and ends at the specified index.</summary>
            <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by
            match, if found; otherwise, 1.</returns>
            <param name="count">The number of elements in the section to search.</param>
            <param name="startIndex">The zero-based starting index of the backward search.</param>
            <param name="match">The Predicate delegate that defines the conditions of the element to search for.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">startIndex is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>
            -or- count is less than 0 -or- startIndex and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ForEach(System.Action{`0})">
            <summary>Performs the specified action on each element of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <param name="action">The Action delegate to perform on each element of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">action is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.GetRange(System.Int32,System.Int32)">
            <summary>Creates a shallow copy of a range of elements in the source <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>A shallow copy of a range of elements in the source <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
            <param name="count">The number of elements in the range.</param>
            <param name="index">The zero-based <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> index at which the range starts.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">index and count do not denote a valid range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.IndexOf(`0,System.Int32)">
            <summary>Searches for the specified object and returns the zero-based index of the first occurrence within
            the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that extends from the specified index to the last element.</summary>
            <returns>The zero-based index of the first occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that
            extends from index to the last element, if found; otherwise, 1.</returns>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
            <param name="index">The zero-based starting index of the search.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>Searches for the specified object and returns the zero-based index of the first occurrence within
            the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that starts at the specified index and contains the specified number of
            elements.</summary>
            <returns>The zero-based index of the first occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that
            starts at index and contains count number of elements, if found; otherwise, 1.</returns>
            <param name="count">The number of elements in the section to search.</param>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
            <param name="index">The zero-based starting index of the search.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>
            -or- count is less than 0 -or- index and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>Inserts the elements of a collection into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> at the specified index.</summary>
            <param name="collection">The collection whose elements should be inserted into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The collection
            itself cannot be null, but it can contain elements that are null, if type T is a reference type.</param>
            <param name="index">The zero-based index at which the new elements should be inserted.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is greater than <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> length.</exception>
            <exception cref="T:System.ArgumentNullException">collection is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.LastIndexOf(`0)">
            <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the
            entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>The zero-based index of the last occurrence of item within the entire the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, if found;
            otherwise, 1.</returns>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.LastIndexOf(`0,System.Int32)">
            <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the
            range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that extends from the first element to the specified index.</summary>
            <returns>The zero-based index of the last occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that
            extends from the first element to index, if found; otherwise, 1.</returns>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
            <param name="index">The zero-based starting index of the backward search.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. </exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the
            range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that contains the specified number of elements and ends at the specified index.</summary>
            <returns>The zero-based index of the last occurrence of item within the range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> that
            contains count number of elements and ends at index, if found; otherwise, 1.</returns>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
            <param name="index">The zero-based starting index of the backward search.</param>
            <param name="count">The number of elements in the section to search.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is outside the range of valid indexes for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> -or-
            count is less than 0 -or- index and count do not specify a valid section in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RemoveAll(System.Predicate{`0})">
            <summary>Removes the all the elements that match the conditions defined by the specified predicate.</summary>
            <returns>The number of elements removed from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
            <param name="match">The Predicate delegate that defines the conditions of the elements to remove.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RemoveRange(System.Int32,System.Int32)">
            <summary>Removes a range of elements from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <param name="count">The number of elements to remove.</param>
            <param name="index">The zero-based starting index of the range of elements to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">index and count do not denote a valid range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Reverse">
            <summary>Reverses the order of the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Reverse(System.Int32,System.Int32)">
            <summary>Reverses the order of the elements in the specified range.</summary>
            <param name="count">The number of elements in the range to reverse.</param>
            <param name="index">The zero-based starting index of the range to reverse.</param>
            <exception cref="T:System.ArgumentException">index and count do not denote a valid range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort">
            <summary>Sorts the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using the default comparer.</summary>
            <exception cref="T:System.InvalidOperationException">The default comparer, Generic.Comparer.Default, cannot find an
            implementation of the IComparable generic interface or the IComparable interface for type T.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>Sorts the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using the specified comparer.</summary>
            <param name="comparer">The Generic.IComparer implementation to use when comparing elements, or null to use
            the default comparer: Generic.Comparer.Default.</param>
            <exception cref="T:System.ArgumentException">The implementation of comparer caused an error during the sort. For
            example, comparer might not return 0 when comparing an item with itself.</exception>
            <exception cref="T:System.InvalidOperationException">the comparer is null and the default comparer,
            Generic.Comparer.Default, cannot find an implementation of the IComparable generic interface or the
            IComparable interface for type T.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>Sorts the elements in a range of elements in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using the specified comparer.</summary>
            <param name="count">The length of the range to sort.</param>
            <param name="index">The zero-based starting index of the range to sort.</param>
            <param name="comparer">The Generic.IComparer implementation to use when comparing elements, or null to use
            the default comparer: Generic.Comparer.Default.</param>
            <exception cref="T:System.ArgumentException">The implementation of comparer caused an error during the sort. For
            example, comparer might not return 0 when comparing an item with itself.</exception>
            <exception cref="T:System.InvalidOperationException">the comparer is null and the default comparer,
            Generic.Comparer.Default, cannot find an implementation of the IComparable generic interface or the
            IComparable interface for type T.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- count is less than 0.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Sort(System.Comparison{`0})">
            <summary>Sorts the elements in the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, using the specified comparison.</summary>
            <param name="comparison">The comparison to use when comparing elements.</param>
            <exception cref="T:System.ArgumentException">The implementation of comparison caused an error during the sort. For
            example, comparison might not return 0 when comparing an item with itself.</exception>
            <exception cref="T:System.ArgumentNullException">comparison is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.TrueForAll(System.Predicate{`0})">
            <summary>Determines whether every element in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> matches the conditions defined by the specified
            predicate.</summary>
            <returns>True, if every element in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> matches the conditions defined by the specified predicate;
            otherwise, false. If the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> has no elements, the return value is true.</returns>
            <param name="match">The Predicate delegate that defines the conditions to check against the elements.</param>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Add(`0)">
            <summary>Adds an item to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <param name="item">The item to add to the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Insert(System.Int32,`0)">
            <summary>Inserts an element into the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> at the specified index.</summary>
            <param name="item">The object to insert. The value can be null for reference types.</param>
            <param name="index">The zero-based index at which item should be inserted.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is greater than <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> length.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> to a compatible one-dimensional array, starting at the beginning of the
            target array.</summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The
            array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentException">arrayIndex is equal to or greater than the length of array -or- the
            number of elements in the source <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is greater than the available space from arrayIndex to the end of the
            destination array.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.IndexOf(`0)">
            <summary>Searches for the specified object and returns the zero-based index of the first occurrence within
            the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>The zero-based index of the first occurrence of item within the entire <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>, if found; otherwise, 1.</returns>
            <param name="item">The object to locate in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Clear">
            <summary>
            Removes all elements from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.Remove(`0)">
            <summary>Removes the first occurrence of a specific object from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <returns>True, if item is successfully removed; otherwise, false. This method also returns false if item was
            not found in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</returns>
            <param name="item">The object to remove from the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>. The value can be null for reference types.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.RemoveAt(System.Int32)">
            <summary>Removes the element at the specified index of the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.</summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than 0 -or- index is equal to or greater than
            <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> length.</exception>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItem(`0)">
            <summary>
            Handles standard processing of a single item. 
            </summary>
            <param name="item">A generic item of type T to be processed.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ProcessItems(`0[])">
            <summary>
            Handles standard processing of multiple items.
            </summary>
            <param name="items">Array of type T.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ProcessTimerThreadProc(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            Processes queued items on an interval.
            </summary>
            <param name="sender">The sender object of the item.</param>
            <param name="e">Arguments for the elapsed event.</param>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ProcessNextItem">
            <summary>
            Processes next item in queue, one at a time (i.e., ProcessingStyle = OneAtATime). 
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.ProcessNextItems">
            <summary>
            Processes next items in an array of items as a group (i.e., ProcessingStyle = ManyAtOnce).
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature)">
            <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100, MaximumThreads = 5,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
            <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100, MaximumThreads = 5,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Int32)">
            <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32)">
            <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new asynchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using  specified settings.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature)">
            <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
            <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) using specified settings.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new synchronous <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) using specified settings.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature)">
            <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
            <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new real-time <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemFunction">Delegate that processes one item at a time.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature)">
            <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100,
            MaximumThreads = 5, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
            <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100,
            MaximumThreads = 5, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Int32)">
            <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32)">
            <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessInterval = 100,
            ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateAsynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new asynchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="maximumThreads">An <see cref="T:System.Int32"/> value that determines the maximum number of threads used to process items.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature)">
            <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
            <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) with the default settings:
            ProcessInterval = 100, ProcessTimeout = Infinite, RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) using specified settings.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateSynchronousQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Double,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new synchronous, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., single process thread) using specified settings.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="processInterval">a <see cref="T:System.Double"/> value which represents the process interval in milliseconds.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature)">
            <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature)">
            <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> with the default settings: ProcessTimeout = Infinite,
            RequeueOnTimeout = False, RequeueOnException = False.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="M:Gemstone.Threading.Collections.ProcessQueue`1.CreateRealTimeQueue(Gemstone.Threading.Collections.ProcessQueue{`0}.ProcessItemsFunctionSignature,Gemstone.Threading.Collections.ProcessQueue{`0}.CanProcessItemFunctionSignature,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new real-time, bulk item <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> using specified settings.
            </summary>
            <param name="processItemsFunction">Delegate that defines a method to process multiple items at once.</param>
            <param name="canProcessItemFunction">Delegate which determines whether an item can be processed.</param>
            <param name="processTimeout">The number of seconds before a process should timeout.</param>
            <param name="requeueOnTimeout">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue an item on timeout.</param>
            <param name="requeueOnException">A <see cref="T:System.Boolean"/> value that indicates whether a process should requeue after an exception.</param>
            <returns>A ProcessQueue object based on type T.</returns>
        </member>
        <member name="T:Gemstone.Threading.Collections.ProcessQueueStatistics">
            <summary>
            Represents the statistics of a <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.IsEnabled">
            <summary>
            Gets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is currently enabled.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.IsProcessing">
            <summary>
            Gets indicator that the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> is actively processing items.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ProcessingInterval">
            <summary>
            Gets the interval, in milliseconds, on which new items begin processing.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ProcessTimeout">
            <summary>
            Gets the maximum time, in milliseconds, allowed for processing an item.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ThreadingMode">
            <summary>
            Gets the current <see cref="T:Gemstone.Threading.Collections.QueueThreadingMode"/> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., synchronous or asynchronous).
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ProcessingStyle">
            <summary>
            Gets the item <see cref="T:Gemstone.Threading.Collections.QueueProcessingStyle"/> for the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> (i.e., one at a time or many at once).
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.RunTime">
            <summary>
            Gets the total amount of time, in seconds, that the process <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/> has been active.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ActiveThreads">
            <summary>
            Gets the current number of active threads.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.QueueCount">
            <summary>
            Gets the number of elements queued for processing in the <see cref="T:Gemstone.Threading.Collections.ProcessQueue`1"/>.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.ItemsBeingProcessed">
            <summary>
            Gets the total number of items currently being processed.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.Collections.ProcessQueueStatistics.TotalProcessedItems">
            <summary>
            Gets the total number of items processed so far.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.ConcurrencyLimiter">
            <summary>
            Task scheduler that limits the number of tasks that can execute in parallel at any given time.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter"/> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/> and a maximum concurrency
            level equal to the number of processors on the current machine.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter"/> class with a
            maximum concurrency level equal to the number of processors on the current machine.
            </summary>
            <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter"/> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>.
            </summary>
            <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel"/>.</param>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter"/> class.
            </summary>
            <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
            <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel"/>.</param>
        </member>
        <member name="P:Gemstone.Threading.ConcurrencyLimiter.CurrentConcurrencyLevel">
            <summary>
            Gets the number of threads that are currently executing tasks concurrently.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel">
            <summary>
            Gets the maximum number of threads that can be executing tasks concurrently.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.SetMaximumConcurrencyLevel(System.Int32)">
            <summary>
            Sets the maximum number of threads that can be executing tasks concurrently.
            </summary>
            <param name="maximumConcurrencyLevel">The maximum concurrency level.</param>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task"/> to the scheduler.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be queued.</param>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task"/> can be executed synchronously
            in this call, and if it can, executes it.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be executed.</param>
            <param name="taskWasPreviouslyQueued">
            A <see cref="T:System.Boolean"/> denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
            <returns>A <see cref="T:System.Boolean"/> value indicating whether the task was executed inline.</returns>
        </member>
        <member name="M:Gemstone.Threading.ConcurrencyLimiter.GetScheduledTasks">
            <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task"/>
            instances currently queued to the scheduler waiting to be executed.
            </summary>
            <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
        </member>
        <member name="T:Gemstone.Threading.InterprocessLock">
            <summary>
            Defines helper methods related to inter-process locking.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.InterprocessLock.DefaultMutexGlobal">
            <summary>
            Default value for <see cref="T:System.Threading.Mutex"/> global flag.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.InterprocessLock.DefaultSemaphoreMaximumCount">
            <summary>
            Default value for <see cref="T:Gemstone.Threading.NamedSemaphore"/> maximum count.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.InterprocessLock.DefaultSemaphoreInitialCount">
            <summary>
            Default value for <see cref="T:Gemstone.Threading.NamedSemaphore"/> initial count.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.InterprocessLock.DefaultSemaphoreGlobal">
            <summary>
            Default value for <see cref="T:Gemstone.Threading.NamedSemaphore"/> global flag.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.Boolean)">
            <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Mutex"/> associated with the running application, typically used to detect whether an instance
            of the application is already running.
            </summary>
            <param name="perUser">Indicates whether to generate a different name for the <see cref="T:System.Threading.Mutex"/> dependent upon the user running the application.</param>
            <returns>A uniquely named inter-process <see cref="T:System.Threading.Mutex"/> specific to the application; <see cref="T:System.Threading.Mutex"/> is created if it does not exist.</returns>
            <remarks>
            <para>
            This function uses a hash of the assembly's GUID when creating the <see cref="T:System.Threading.Mutex"/>, if it is available. If it is not available, it uses a hash
            of the simple name of the assembly. Although the name is hashed to help guarantee uniqueness, it is still entirely possible that another application
            may use that name with the same hashing algorithm to generate its <see cref="T:System.Threading.Mutex"/> name. Therefore, it is best to ensure that the
            <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> is defined in the AssemblyInfo of your application.
            </para>
            </remarks>
            <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the minimum needed security access rights to use it.</exception>
        </member>
        <member name="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.String,System.Boolean)">
            <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Mutex"/> associated with the specified <paramref name="name"/> that identifies a source object
            needing concurrency locking.
            </summary>
            <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
            <param name="global">Determines if mutex should be marked as global; set value to <c>false</c> for local.</param>
            <returns>A uniquely named inter-process <see cref="T:System.Threading.Mutex"/> specific to <paramref name="name"/>; <see cref="T:System.Threading.Mutex"/> is created if it does not exist.</returns>
            <remarks>
            <para>
            This function uses a hash of the <paramref name="name"/> when creating the <see cref="T:System.Threading.Mutex"/>, not the actual <paramref name="name"/> - this way
            restrictions on the <paramref name="name"/> length do not need to be a user concern. All processes needing an inter-process <see cref="T:System.Threading.Mutex"/> need
            to use this same function to ensure access to the same <see cref="T:System.Threading.Mutex"/>.
            </para>
            <para>
            The <paramref name="name"/> can be a string of any length (must not be empty, null or white space) and is not case-sensitive. All hashes of the
            <paramref name="name"/> used to create the global <see cref="T:System.Threading.Mutex"/> are first converted to lower case.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Argument <paramref name="name"/> cannot be empty, null or white space.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the minimum needed security access rights to use it.</exception>
        </member>
        <member name="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Gets a uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore"/> associated with the running application, typically used to detect whether some number of
            instances of the application are already running.
            </summary>
            <param name="perUser">Indicates whether to generate a different name for the <see cref="T:Gemstone.Threading.NamedSemaphore"/> dependent upon the user running the application.</param>
            <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently, or -1 to default to <paramref name="maximumCount"/>.</param>
            <returns>A uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore"/> specific to entry assembly; <see cref="T:Gemstone.Threading.NamedSemaphore"/> is created if it does not exist.</returns>
            <remarks>
            <para>
            This function uses a hash of the assembly's GUID when creating the <see cref="T:Gemstone.Threading.NamedSemaphore"/>, if it is available. If it is not available, it uses a hash
            of the simple name of the assembly. Although the name is hashed to help guarantee uniqueness, it is still entirely possible that another application
            may use that name with the same hashing algorithm to generate its <see cref="T:Gemstone.Threading.NamedSemaphore"/> name. Therefore, it is best to ensure that the
            <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> is defined in the AssemblyInfo of your application.
            </para>
            <para>
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore"/> exhibits kernel persistence, meaning instances will remain active beyond the lifespan of the
            creating process. Named semaphores must be explicitly removed by invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/> when they are no longer needed.
            Kernel persistence necessitates careful design consideration regarding the responsibility for invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/>.
            Since the common use case for named semaphores is across multiple applications, it is advisable for the last exiting process to handle the
            cleanup. In cases where an application may crash before calling <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/>, the semaphore persists in the system,
            potentially leading to resource leakage. Implementations should include strategies to address and mitigate this risk.
            </para>
            </remarks>
            <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the minimum needed security access rights to use it.</exception>
        </member>
        <member name="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Gets a uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore"/> associated with the specified <paramref name="name"/> that identifies a source object
            needing concurrency locking.
            </summary>
            <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
            <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently, or -1 to default to <paramref name="maximumCount"/>.</param>
            <param name="global">Determines if semaphore should be marked as global; set value to <c>false</c> for local.</param>
            <returns>A uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore"/> specific to <paramref name="name"/>; <see cref="T:Gemstone.Threading.NamedSemaphore"/> is created if it does not exist.</returns>
            <remarks>
            <para>
            This function uses a hash of the <paramref name="name"/> when creating the <see cref="T:Gemstone.Threading.NamedSemaphore"/>, not the actual <paramref name="name"/> - this way
            restrictions on the <paramref name="name"/> length do not need to be a user concern. All processes needing an inter-process <see cref="T:Gemstone.Threading.NamedSemaphore"/> need
            to use this same function to ensure access to the same <see cref="T:Gemstone.Threading.NamedSemaphore"/>.
            </para>
            <para>
            The <paramref name="name"/> can be a string of any length (must not be empty, null or white space) and is not case-sensitive. All hashes of the
            <paramref name="name"/> used to create the global <see cref="T:Gemstone.Threading.NamedSemaphore"/> are first converted to lower case.
            </para>
            <para>
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore"/> exhibits kernel persistence, meaning instances will remain active beyond the lifespan of the
            creating process. Named semaphores must be explicitly removed by invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/> when they are no longer needed.
            Kernel persistence necessitates careful design consideration regarding the responsibility for invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/>.
            Since the common use case for named semaphores is across multiple applications, it is advisable for the last exiting process to handle the
            cleanup. In cases where an application may crash before calling <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/>, the semaphore persists in the system,
            potentially leading to resource leakage. Implementations should include strategies to address and mitigate this risk.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Argument <paramref name="name"/> cannot be empty, null or white space.</exception>
            <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the minimum needed security access rights to use it.</exception>
        </member>
        <member name="T:Gemstone.Threading.InterprocessReaderWriterLock">
            <summary>
            Represents an inter-process reader/writer lock using <see cref="T:Gemstone.Threading.NamedSemaphore"/> and <see cref="T:System.Threading.Mutex"/>
            native locking mechanisms.
            </summary>
            <remarks>
            <para>
            The <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> uses a <see cref="T:Gemstone.Threading.NamedSemaphore"/> to synchronize access to an inter-process shared resource.
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore"/> exhibits kernel persistence, meaning instances will remain active beyond the lifespan of
            the creating process. The named semaphore must be explicitly removed by invoking <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources"/> when the last
            reader-writer lock instance is no longer needed. Kernel persistence necessitates careful design consideration regarding process
            responsibility for invoking the <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources"/> method. Since the common use case for named semaphores is across
            multiple applications, it is advisable for the last exiting process to handle the cleanup. In cases where an application may crash before
            calling the <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources"/> method, the semaphore persists in the system, potentially leading to resource leakage.
            Implementations should include strategies to address and mitigate this risk.
            </para>
            </remarks>
        </member>
        <member name="F:Gemstone.Threading.InterprocessReaderWriterLock.DefaultMaximumConcurrentLocks">
            <summary>
            Default maximum concurrent locks allowed for <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> associated with the specified
            <paramref name="name"/> that identifies a source object needing concurrency locking.
            </summary>
            <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
            <param name="global">Determines if semaphore and mutex used by <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> should be marked as global; set value to <c>false</c> for local.</param>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> associated with the specified
            <paramref name="name"/> that identifies a source object needing concurrency locking.
            </summary>
            <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
            <param name="maximumConcurrentLocks">Maximum concurrent reader locks to allow.</param>
            <param name="global">Determines if semaphore and mutex used by <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> should be marked as global; set value to <c>false</c> for local.</param>
            <remarks>
            If more reader locks are requested than the <paramref name="maximumConcurrentLocks"/>, excess reader locks will simply
            wait until a lock is available (i.e., one of the existing reads completes).
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Finalize">
            <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> object is reclaimed by <see cref="T:System.GC"/>.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.InterprocessReaderWriterLock.MaximumConcurrentLocks">
            <summary>
            Gets the maximum concurrent reader locks allowed.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose">
            <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> object.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/> object and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock">
            <summary>
            Tries to enter the lock in read mode.
            </summary>
            <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock"/>.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock"/> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock"/> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock">
            <summary>
            Tries to enter the lock in write mode.
            </summary>
            <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock"/>.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock"/> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock"/> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock">
            <summary>
            Exits read mode and returns the prior read lock count.
            </summary>
            <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock"/>.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock"/> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock"/> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock">
            <summary>
            Exits write mode.
            </summary>
            <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock"/>.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock"/> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock"/> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)">
            <summary>
            Tries to enter the lock in read mode, with an optional time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <returns><c>true</c> if the calling thread entered read mode, otherwise, <c>false</c>.</returns>
            <remarks>
            <para>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock"/>.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock"/> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock"/> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)"/>.
            </para>
            <para>
            Note that this function may wait as long as 2 * <paramref name="millisecondsTimeout"/> since the function first waits for synchronous access
            to the semaphore, then waits again on an available semaphore slot.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)">
            <summary>
            Tries to enter the lock in write mode, with an optional time-out.
            </summary>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite"/>) to wait indefinitely.</param>
            <returns><c>true</c> if the calling thread entered write mode, otherwise, <c>false</c>.</returns>
            <remarks>
            <para>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock"/>.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock"/> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock"/> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)"/>.
            </para>
            <para>
            Note that this function may wait as long as 2 * <paramref name="millisecondsTimeout"/> since the function first waits for synchronous access
            to the semaphore, then waits again on an available semaphore slot.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources">
            <summary>
            Releases inter-process resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock"/>.
            </summary>
            <remarks>
            On POSIX systems, calling this method removes the named semaphore used by the reader-writer lock.
            The semaphore name is removed immediately and is destroyed once all other processes that have the
            semaphore open close it. Calling this method on Windows systems does nothing.
            </remarks>
        </member>
        <member name="T:Gemstone.Threading.NamedSemaphore">
            <summary>
            Represents a cross-platform, interprocess named semaphore, which limits the number of threads that can concurrently 
            access a resource or a pool of resources.
            </summary>
            <remarks>
            <para>
            A <see cref="T:Gemstone.Threading.NamedSemaphore"/> is a synchronization object that can be utilized across multiple processes.
            </para>
            <para>
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore"/> exhibits kernel persistence, meaning instances will remain
            active beyond the lifespan of the creating process. Named semaphores must be explicitly removed by invoking 
            <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/> when they are no longer needed. Kernel persistence necessitates careful design consideration
            regarding the responsibility for invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/>. Since the common use case for named semaphores is
            across multiple applications, it is advisable for the last exiting process to handle the cleanup. In cases where
            an application may crash before calling <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink"/>, the semaphore persists in the system, potentially
            leading to resource leakage. Implementations should include strategies to address and mitigate this risk.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Threading.NamedSemaphore" /> class, specifying the initial number of entries,
            the maximum number of concurrent entries, and the name of a system semaphore object.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
            <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
            <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
            <remarks>
            The <paramref name="name"/> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Threading.NamedSemaphore" /> class, specifying the initial number of entries,
            the maximum number of concurrent entries, the name of a system semaphore object, and specifying a variable that
            receives a value indicating whether a new system semaphore was created.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
            <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
            <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
            <param name="createdNew">
            When method returns, contains <c>true</c> if the specified named system semaphore was created; otherwise,
            <c>false</c> if the semaphore already existed.
            </param>
            <remarks>
            The <paramref name="name"/> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.NamedSemaphore.SafeWaitHandle">
            <summary>
            Gets or sets the native operating system handle.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.NamedSemaphore.Name">
            <summary>
            Gets the name of the <see cref="T:Gemstone.Threading.NamedSemaphore" />.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.Dispose(System.Boolean)">
            <summary>
            When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.NamedSemaphore" />,
            and optionally releases the managed resources.
            </summary>
            <param name="explicitDisposing">
            <c>true</c> to release both managed and unmanaged resources; otherwise, <c>false</c> to release only
            unmanaged resources.
            </param>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.Close">
            <summary>
            Releases all resources held by the current <see cref="T:Gemstone.Threading.NamedSemaphore" />.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne">
            <summary>
            Blocks the current thread until the current <see cref="T:Gemstone.Threading.NamedSemaphore" /> receives a signal.
            </summary>
            <returns>
            <c>true</c> if the current instance receives a signal. If the current instance is never signaled,
            <see cref="T:Gemstone.Threading.NamedSemaphore" /> never returns.
            </returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.TimeSpan)">
            <summary>
            Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" />
            to specify the time interval.
            </summary>
            <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" />
            that represents -1 milliseconds to wait indefinitely.
            </param>
            <returns><c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.Int32)">
            <summary>
            Blocks the current thread until the current instance receives a signal, using a 32-bit signed integer to
            specify the time interval in milliseconds.
            </summary>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.
            </param>
            <returns><c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.TimeSpan,System.Boolean)">
            <summary>
            Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" />
            to specify the time interval and specifying whether to exit the synchronization domain before the wait.
            </summary>
            <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" />
            that represents -1 milliseconds to wait indefinitely.
            </param>
            <param name="exitContext">
            <c>true</c> to exit the synchronization domain for the context before the wait (if in a synchronized context),
            and reacquire it afterward; otherwise, <c>false</c>.
            </param>
            <returns><c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.Int32,System.Boolean)">
            <summary>
            Blocks the current thread until the current <see cref="T:Gemstone.Threading.NamedSemaphore" /> receives a signal, using a
            32-bit signed integer to specify the time interval and specifying whether to exit the synchronization
            domain before the wait.
            </summary>
            <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.
            </param>
            <param name="exitContext">
            <c>true</c> to exit the synchronization domain for the context before the wait (if in a synchronized context),
            and reacquire it afterward; otherwise, <c>false</c>.
            </param>
            <returns><c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.Release">
            <summary>
            Exits the semaphore and returns the previous count.
            </summary>
            <returns>The count on the semaphore before the method was called.</returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.Release(System.Int32)">
            <summary>
            Exits the semaphore a specified number of times and returns the previous count.
            </summary>
            <param name="releaseCount">The number of times to exit the semaphore.</param>
            <returns>The count on the semaphore before the method was called.</returns>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.Unlink">
            <summary>
            Removes a named semaphore.
            </summary>
            <remarks>
            On POSIX systems, calling this method removes the named semaphore referred to by <see cref="P:Gemstone.Threading.NamedSemaphore.Name"/>.
            The semaphore name is removed immediately and is destroyed once all other processes that have the semaphore
            open close it. Calling this method on Windows systems does nothing.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.OpenExisting(System.String)">
            <summary>
            Opens an existing named semaphore.
            </summary>
            <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
            <returns>
            An object that represents the opened named semaphore.
            </returns>
            <remarks>
            The <paramref name="name"/> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.TryOpenExisting(System.String,Gemstone.Threading.NamedSemaphore@)">
            <summary>
            Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the
            operation succeeded.
            </summary>
            <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
            <param name="semaphore">
            When this method returns, contains a <see cref="T:Gemstone.Threading.NamedSemaphore" /> object that represents the named semaphore
            if the call succeeded, or <c>null</c> if the call failed. This parameter is treated as uninitialized.
            </param>
            <returns>
            <c>true</c> if the named semaphore was opened successfully; otherwise, <c>false</c>. In some cases,
            <c>false</c> may be returned for invalid names.
            </returns>
            <remarks>
            The <paramref name="name"/> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.NamedSemaphore.Unlink(System.String)">
            <summary>
            Removes a named semaphore.
            </summary>
            <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
            <remarks>
            On POSIX systems, calling this method removes the named semaphore referred to by <paramref name="name"/>.
            The semaphore name is removed immediately and is destroyed once all other processes that have the semaphore
            open close it. Calling this method on Windows systems does nothing.
            </remarks>
        </member>
        <member name="T:Gemstone.Threading.NamespaceDoc">
            <summary>
            The <see cref="N:Gemstone.Threading"/> namespace organizes all Gemstone library functionality
            related to threading. The root threading namespace also includes common threading classes,
            e.g., <see cref="T:Gemstone.Threading.ConcurrencyLimiter"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.RateLimiter">
            <summary>
            A rate limiting system based on tokes.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.RateLimiter.#ctor(System.Double,System.Int32)">
            <summary>
            Creates a <see cref="T:Gemstone.Threading.RateLimiter"/>
            </summary>
            <param name="tokensPerSecond">The number of tokens per second that can be generated. Must be greater than zero and less than 1 billion</param>
            <param name="maxTokensQueue">The maximum number of tokens in the queue. Must be at least 1</param>
        </member>
        <member name="M:Gemstone.Threading.RateLimiter.UpdateLimits(System.Double,System.Int32)">
            <summary>
            Updates the limits associated with this rate limiter. Note, after this update, the tokens will be completely resupplied.
            </summary>
            <param name="tokensPerSecond">The number of tokens per second that can be generated. Must be greater than zero and less than 1 billion</param>
            <param name="maxTokensQueue">The maximum number of tokens in the queue. Must be at least 1</param>
        </member>
        <member name="M:Gemstone.Threading.RateLimiter.TryTakeToken">
            <summary>
            Attempts to take a token from the rate limiter.
            </summary>
            <returns>true if token was successfully taken, False if all tokens were consumed.</returns>
        </member>
        <member name="T:Gemstone.Threading.ReaderWriterSpinLock">
            <summary>
            Represents a fast, lightweight reader/writer lock that uses spinning to perform locking. No recursive acquires or
            upgradable locks are allowed (i.e., all entered locks must be exited before entering another lock).
            </summary>
            <remarks>
            This reader/writer lock uses <see cref="T:System.Threading.SpinWait"/> to spin the CPU instead of engaging event based locking. As a result it
            should only be used in cases where lock times are expected to be very small, reads are very frequent and writes are rare.
            If hold times for write locks can be lengthy, it will be better to use <see cref="T:System.Threading.ReaderWriterLockSlim"/> instead to avoid
            unnecessary CPU utilization due to spinning incurred by waiting reads.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.ReaderWriterSpinLock.EnterWriteLock">
            <summary>
            Enters the lock in write mode.
            </summary>
            <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock"/>.
            One <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock"/> should be called for each <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.EnterWriteLock"/>.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock">
            <summary>
            Exits write mode.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ReaderWriterSpinLock.EnterReadLock">
            <summary>
            Enters the lock in read mode.
            </summary>
            <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock"/>.
            One <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock"/> should be called for each <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.EnterReadLock"/>.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock">
            <summary>
            Exits read mode.
            </summary>
            <exception cref="T:System.InvalidOperationException">Cannot exit read lock when there are no readers.</exception>
        </member>
        <member name="T:Gemstone.Threading.ThreadingMode">
            <summary>
            Specifies the threading mode to use for the <see cref="T:Gemstone.Threading.ScheduledTask"/>
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadingMode.DedicatedForeground">
            <summary>
            A dedicated thread that is a foreground thread.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadingMode.DedicatedBackground">
            <summary>
            A dedicated thread that is a background thread.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadingMode.ThreadPool">
            <summary>
            A background thread from the thread pool.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.ScheduledTaskRunningReason">
            <summary>
            Metadata about why this worker was called.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ScheduledTaskRunningReason.Running">
            <summary>
            A normal run was scheduled.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ScheduledTaskRunningReason.Disposing">
            <summary>
            Dispose was called and execution will terminate after this function call.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.ScheduledTask">
            <summary>
            Represents a way to schedule a task to be executed on a separate thread immediately or after a given time delay.
            </summary>
        </member>
        <member name="E:Gemstone.Threading.ScheduledTask.Running">
            <summary>
            Occurs every time the task should run.
            </summary>
        </member>
        <member name="E:Gemstone.Threading.ScheduledTask.Disposing">
            <summary>
            Occurs right before this task is disposed.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ScheduledTask.#ctor(Gemstone.Threading.ThreadingMode,System.Threading.ThreadPriority,System.Boolean)">
            <summary>
            Creates a <see cref="T:Gemstone.Threading.ScheduledTask"/>.
            </summary>
            <param name="threadMode">The manner in which the scheduled task executes.</param>
            <param name="priority">The thread priority to assign if a dedicated thread is used. This is ignored if using the thread-pool.</param>
            <param name="disposeOnShutdown">Adds a handler to <see cref="T:Gemstone.Threading.ShutdownHandler"/> that requires this class to be disposed
            when the application is shutdown. Note: If this object has been garbage collected, this will have no effect.</param>
        </member>
        <member name="M:Gemstone.Threading.ScheduledTask.Finalize">
            <summary>
            Cleans up the <see cref="T:Gemstone.Threading.ThreadContainerBase"/> thread since that class likely will never be garbage collected.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ScheduledTask.IgnoreShutdownEvent">
            <summary>
            For foreground threads, a shutdown handler is registered to dispose of the Thread so it doesn't keep the process running. 
            However, for the Logger, shutting down this thread will prevent shutdown messages from showing up in the logger. 
            By calling this method, it declares that the coder will dispose of this class when it is finished and does not want the 
            Shutdown handler to do it.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ScheduledTask.Start">
            <summary>
            Starts the task immediately, or if one was scheduled, starts the scheduled task immediately
            </summary>
            <remarks>
            <para>
            If this is called after a <see cref="M:Gemstone.Threading.ScheduledTask.Start(System.Int32)"/> the timer will be canceled
            and the process will still start immediately. 
            </para>
            <para>
            This method is safe to call from any thread, including the worker thread.
            If disposed, this method will no nothing.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.ScheduledTask.Start(System.Int32)">
            <summary>
            Starts a timer to run the task after a provided interval. 
            </summary>
            <param name="delay">the delay in milliseconds before the task should run</param>
            <remarks>
            <para>
            If a timer is currently pending, this function will do nothing. Do not use this
            function to reset or restart an existing timer.
            </para>
            <para>
            If called while working, a subsequent timer will be scheduled, but delay will not
            start until after the worker has completed.
            </para>
            <para>
            This method is safe to call from any thread, including the worker thread.
            If disposed, this method will no nothing.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.ScheduledTask.Dispose">
            <summary>
            Starts the disposing process of exiting the worker thread. 
            </summary>
            <remarks>
            <para>Callback will be invoked one more time. Duplicate calls are ignored.</para>
            <para>
            Unless called from the worker thread, this method will block until the dispose
            has successfully completed.
            </para>
            </remarks>
        </member>
        <member name="T:Gemstone.Threading.SharedTimer">
            <summary>
            Represents a timer class that will group registered timer event callbacks that operate on the same
            interval in order to optimize thread pool queuing.
            </summary>
            <remarks>
            <para>
            Externally the <see cref="T:Gemstone.Threading.SharedTimer"/> operations similar to the <see cref="T:System.Timers.Timer"/>.
            Internally the timer pools callbacks with the same <see cref="P:Gemstone.Threading.SharedTimer.Interval"/> into a single timer where
            each callback is executed on the same thread, per instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler"/>. 
            </para>
            <para>
            Any long running callbacks that have a risk of long delays should not use <see cref="T:Gemstone.Threading.SharedTimer"/>
            as this will effect the reliability of all of the other <see cref="T:Gemstone.Threading.SharedTimer"/> instances for a
            given <see cref="T:Gemstone.Threading.SharedTimerScheduler"/>.
            </para>
            </remarks>
        </member>
        <member name="E:Gemstone.Threading.SharedTimer.Elapsed">
            <summary>
            Occurs when the timer interval elapses.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimer.#ctor(Gemstone.Threading.SharedTimerScheduler,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Threading.SharedTimer"/>.
            </summary>
            <param name="scheduler">The scheduler to use.</param>
            <param name="interval">The interval of the timer, default is 100.</param>
        </member>
        <member name="P:Gemstone.Threading.SharedTimer.AutoReset">
            <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only
            once <c>false</c> or repeatedly <c>true</c>.
            </summary>
            <returns>
            <c>true</c> the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event each time the interval elapses; otherwise,
            <c>false</c> if it should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only once, after the first time the interval elapses.
            The default is <c>true</c>.
            </returns>
        </member>
        <member name="P:Gemstone.Threading.SharedTimer.Enabled">
            <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
            <returns>
            <c>true</c> if the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event; otherwise, <c>false</c>.
            The default is <c>false</c>.
            </returns>
        </member>
        <member name="P:Gemstone.Threading.SharedTimer.Interval">
            <summary>
            Gets or sets the interval at which to raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
            <returns>The time, in milliseconds, between <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> events.</returns>
            <remarks>
            The value must be greater than zero, and less than or equal to <see cref="F:System.Int32.MaxValue" />.
            The default is 100 milliseconds.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.SharedTimer.Status">
            <summary>
            Gets the current status details about object providing status information.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimer.Close">
            <summary>
            Stops the timer.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimer.Dispose">
            <summary>
            Stops the timer and prevents reuse of the class.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimer.Start">
            <summary>
            Starts raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>true</c>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimer.Stop">
            <summary>
            Stops raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed"/> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>false</c>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimer.TimerCallback(System.DateTime)">
            <summary>
            Callback from <see cref="T:Gemstone.Threading.SharedTimerScheduler"/>.
            </summary>
            <param name="state">The time that the callback was signaled.</param>
        </member>
        <member name="T:Gemstone.Threading.SharedTimerScheduler">
            <summary>
            Represents a timer manager which is the scheduler of <see cref="T:Gemstone.Threading.SharedTimer"/>.
            </summary>
            <remarks>
            A <see cref="T:Gemstone.Threading.SharedTimer"/> with the same scheduler will use the same ThreadPool thread to process
            all of the <see cref="T:Gemstone.Threading.SharedTimer"/> instances in series when they have a common interval. Call
            order, based on registration sequence, will be preserved.
            </remarks>
        </member>
        <member name="F:Gemstone.Threading.SharedTimerScheduler.SharedTimerInstance.m_sumOfCallbacks">
            Total number of callbacks that have occurred
        </member>
        <member name="F:Gemstone.Threading.SharedTimerScheduler.SharedTimerInstance.m_sharedTimersCount">
            Count of the number of timer callbacks that exists in this factory
        </member>
        <member name="M:Gemstone.Threading.SharedTimerScheduler.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler"/> class.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SharedTimerScheduler.IsDisposed">
            <summary>
            Gets flag that determines if this <see cref="T:Gemstone.Threading.SharedTimerScheduler"/> instance has been disposed.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SharedTimerScheduler.CreateTimer(System.Int32)">
            <summary>
            Creates a <see cref="T:Gemstone.Threading.SharedTimer"/> using the current <see cref="T:Gemstone.Threading.SharedTimerScheduler"/>.
            </summary>
            <param name="interval">The interval of the timer, default is 100.</param>
            <returns>A shared timer instance that fires at the given interval.</returns>
        </member>
        <member name="M:Gemstone.Threading.SharedTimerScheduler.GetStatus(System.Int32)">
            <summary>
            Attempts to get status of <see cref="T:Gemstone.Threading.SharedTimerScheduler.SharedTimerInstance"/> for specified <paramref name="interval"/>.
            </summary>
            <param name="interval">The interval of the timer.</param>
            <returns>Timer status.</returns>
        </member>
        <member name="M:Gemstone.Threading.SharedTimerScheduler.RegisterCallback(System.Int32,System.Action{System.DateTime})">
            <summary>
            Registers the given callback with the timer running at the given interval.
            </summary>
            <param name="interval">The interval at which to run the timer.</param>
            <param name="callback">The action to be performed when the timer is triggered.</param>
            <returns>
            The weak reference callback that will be executed when this timer fires. To unregister
            the callback, call <see cref="M:Gemstone.Threading.WeakAction.Clear"/>.
            </returns>
        </member>
        <member name="M:Gemstone.Threading.SharedTimerScheduler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.ShutdownHandlerOrder">
            <summary>
            The order in which the specified callback should occur when shutting down.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ShutdownHandlerOrder.First">
            <summary>
            This queue is processed first. Unless there is a compelling reason to execute first, select the Default one. 
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ShutdownHandlerOrder.Default">
            <summary>
            This shutdown order occurs after First, but before Last. 
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ShutdownHandlerOrder.Last">
            <summary>
            This queue is processed last. Items such as flushing application logs should go here.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.ShutdownHandler">
            <summary>
            This class will monitor the state to the application and raise events when it detects that the application is about to shutdown.
            </summary>
            <remarks>
            This class is duplicated here from the Gemstone.Diagnostics project as an internal class to avoid a circular dependency.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.ShutdownHandler.IsShuttingDown">
            <summary>
            Gets if this process is shutting down.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.ShutdownHandler.HasShutdown">
            <summary>
            Gets if this process has already shut down.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ShutdownHandler.Initialize">
            <summary>
            Initializes the shutdown handler. This is recommended to put in main loop of the program, but it is not critical.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ShutdownHandler.TryRegisterCallback(System.Action,Gemstone.Threading.ShutdownHandlerOrder)">
            <summary>
            Attempts Registers a callback that will be called
            when the application is shutdown.
            </summary>
            <param name="callback">the callback when the shutdown occurs</param>
            <param name="shutdownOrder">the order that the callback will occur.</param>
            <returns></returns>
        </member>
        <member name="T:Gemstone.Threading.Strands.NamespaceDoc">
            <summary>
            The <see cref="N:Gemstone.Threading.Strands"/> namespace provides classes for strands, which are FIFO based
            synchronized task queues, e.g., <see cref="T:Gemstone.Threading.Strands.Strand"/> and <see cref="T:Gemstone.Threading.Strands.PriorityStrand"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.Strands.PriorityStrand">
            <summary>
            Schedules tasks in a collection of FIFO queues and executes them in priority order.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand"/> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand"/> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>.
            </summary>
            <param name="priorityLevels">The number of priority levels to be preallocated by the priority queue.</param>
        </member>
        <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand"/> class.
            </summary>
            <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
        </member>
        <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand"/> class.
            </summary>
            <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
            <param name="priorityLevels">The number of priority levels to be preallocated by the priority queue.</param>
        </member>
        <member name="M:Gemstone.Threading.Strands.PriorityStrand.GetScheduler(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.TaskScheduler"/> used to queue tasks at a specific priority.
            </summary>
            <param name="priority">The priority at which tasks should be queued by the returned <see cref="T:System.Threading.Tasks.TaskScheduler"/>. Higher numbers are higher in priority!</param>
            <returns>A <see cref="T:System.Threading.Tasks.TaskScheduler"/> that queues tasks into the strand at the given priority.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="priority"/> is less than zero</exception>
            <remarks>For a strand with <c>n</c> priorities, it is recommended to use priority levels between <c>0</c> and <c>n-1</c> inclusive.</remarks>
        </member>
        <member name="T:Gemstone.Threading.Strands.Strand">
            <summary>
            Schedules tasks in a FIFO queue and executes them in a synchronized asynchronous loop.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Strands.Strand.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand"/> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Strands.Strand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand"/> class.
            </summary>
            <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
        </member>
        <member name="P:Gemstone.Threading.Strands.Strand.MaximumConcurrencyLevel">
            <summary>
            Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler"/> is able to support.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.Strands.Strand.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task"/> to the scheduler.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be queued.</param>
        </member>
        <member name="M:Gemstone.Threading.Strands.Strand.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Attempts to executes a task inline, but only if this method is
            called on the processing thread to avoid parallel execution of tasks.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be executed.</param>
            <param name="taskWasPreviouslyQueued">
            A Boolean denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
            <returns>A Boolean value indicating whether the task was executed inline.</returns>
            <remarks>
            Inline execution allows tasks to skip the line and run out of order.
            The only reason inline execution is supported at all is to avoid a common
            case of deadlocking where a task is queued in advance of another task that it
            depends on (via <see cref="M:System.Threading.Tasks.Task.Wait"/>, for instance). However, deadlocks can
            still occur when waiting on tasks scheduled by a different strand. To avoid
            out-of-order execution and deadlocks, be very careful about using API calls
            that wait on tasks.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.Strands.Strand.TryDequeue(System.Threading.Tasks.Task)">
            <summary>
            Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task"/> that was previously queued to this scheduler.
            </summary>
            <param name="task">The <see cref="T:System.Threading.Tasks.Task"/> to be dequeued.</param>
            <returns>A Boolean denoting whether the task argument was successfully dequeued.</returns>
        </member>
        <member name="M:Gemstone.Threading.Strands.Strand.GetScheduledTasks">
            <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task"/>
            instances currently queued to the scheduler waiting to be executed.
            </summary>
            <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation">
            <summary>
            Represents a short-running synchronized operation that cannot run while it is already
            in progress. Async operations will execute on the thread-pool after the specified
            <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/> in milliseconds.
            </summary>
            <remarks>
            By default, the action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>
            is executed on the <see cref="T:System.Threading.ThreadPool"/> when running the operation asynchronously.
            When the operation is set to pending, the action is executed in an asynchronous loop on
            the thread pool until all pending operations have been completed. Since the action is
            executed on the thread pool, it is best if it can be executed quickly, without
            blocking the thread or putting it to sleep. If completion of the operation is
            critical, such as when saving data to a file, this type of operation should not
            be used since thread pool threads are background threads and will not prevent the
            program from ending before the operation is complete.
            </remarks>
        </member>
        <member name="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay">
            <summary>
            Defines the default value for the <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/> property.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/> class.
            </summary>
            <param name="action">The cancellable action to be performed during this operation.</param>
            <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/> class.
            </summary>
            <param name="action">The cancellable action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
            <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay">
            <summary>
            Gets or sets the amount of time to wait before execution, in milliseconds,
            for any asynchronous calls. Zero value will execute immediately.
            </summary>
            <remarks>
            Non asynchronous calls will not be delayed.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Run(System.Boolean)">
            <summary>
            Executes the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/> in milliseconds or marks
            the operation as pending if the operation is already running. Method same as <see cref="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync"/> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.
            </summary>
            <param name="runPendingSynchronously">
            Defines synchronization mode for running any pending operation; must be <c>false</c> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.
            </param>
            <remarks>
            <para>
            For <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>, actions will always run on another thread so this method is
            hidden from intellisense.
            </para>
            <para>
            When the operation is marked as pending, it will run again after the operation that is currently running
            has completed. This is useful if an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="runPendingSynchronously"/> must be <c>false</c> for <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.
            </exception>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRun(System.Boolean)">
            <summary>
            Attempts to execute the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/> in milliseconds.
            Does nothing if the operation is already running. Method same as <see cref="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync"/> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.
            </summary>
            <param name="runPendingSynchronously">
            Defines synchronization mode for running any pending operation; must be <c>false</c> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.
            </param>
            <remarks>
            For <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>, actions will always run on another thread so this method is
            hidden from intellisense.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            <paramref name="runPendingSynchronously"/> must be <c>false</c> for <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.
            </exception>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync">
            <summary>
            Executes the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/> in milliseconds or marks
            the operation as pending if the operation is already running
            </summary>
            <remarks>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync">
            <summary>
            Attempts to execute the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/> in milliseconds.
            Does nothing if the operation is already running.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.ExecuteActionAsync">
            <summary>
            Executes the action on a separate thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay"/>.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Factory(System.Action)">
            <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory"/> signature.
            </summary>
            <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/>.</param>
            <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation"/> with <see cref="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay"/> of 1000 milliseconds.</returns>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory">
            <summary>
            Factory method for creating synchronized operations.
            </summary>
            <param name="action">The action to be synchronized by the operation.</param>
            <returns>The operation that synchronizes the given action.</returns>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType">
            <summary>
            Represents the available types of synchronized operations.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.Short">
            <summary>
            <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>
            </summary>
        </member>
        <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.Long">
            <summary>
            <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/>
            </summary>
        </member>
        <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.LongBackground">
            <summary>
            <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/> with IsBackground set to <c>true</c>
            </summary>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation">
            <summary>
            Represents an operation that cannot run while it is already in progress.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsRunning">
            <summary>
            Gets flag indicating if the synchronized operation is currently executing its action.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsPending">
            <summary>
            Gets flag indicating if the synchronized operation has an additional operation that is pending
            execution after the currently running action has completed.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.CancellationToken">
            <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken"/> to use for canceling actions.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.Run(System.Boolean)">
            <summary>
            Executes the action on current thread or marks the operation as pending if the operation is already running.
            </summary>
            <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
            <remarks>
            <para>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </para>
            <para>
            When <paramref name="runPendingSynchronously"/> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRun(System.Boolean)">
            <summary>
            Attempts to execute the action on current thread. Does nothing if the operation is already running.
            </summary>
            <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
            <remarks>
            When <paramref name="runPendingSynchronously"/> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync">
            <summary>
            Executes the action on another thread or marks the operation as pending if the operation is already running.
            </summary>
            <remarks>
            When the operation is marked as pending, it will run again after the operation that is currently running
            has completed. This is useful if an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync">
            <summary>
            Attempts to execute the action on another thread. Does nothing if the operation is already running.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation">
            <summary>
            Represents a long-running synchronized operation that cannot run while it is already in progress.
            </summary>
            <remarks>
            The action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/> is executed on
            its own dedicated thread when running the operation in the foreground asynchronously.
            When running on its own thread, the action is executed in a tight loop until all
            pending operations have been completed. This type of synchronized operation should
            be preferred if operations may take a long time, block the thread, or put it to sleep.
            It is also recommended to prefer this type of operation if the speed of the operation
            is not critical or if completion of the operation is critical, such as when saving data
            to a file.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/> class.
            </summary>
            <param name="action">The cancellable action to be performed during this operation.</param>
            <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
            <param name="exceptionAction">The cancellable action to be performed if an exception is thrown from the action.</param>
            <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.IsBackground">
            <summary>
            Gets or sets whether or not the thread executing the action is a background thread.
            </summary>
            <remarks>
            This defaults to <c>false</c>, be aware that foreground thread will prevent shutdown
            while task is running. If a task keeps getting marked as pending, application will not
            shutdown; consider a cancellable action for <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/>
            instances that use a foreground thread.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.ExecuteActionAsync">
            <summary>
            Executes the action on a separate thread.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.Factory(System.Action)">
            <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory"/> signature.
            </summary>
            <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/>.</param>
            <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/>.</returns>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.NamespaceDoc">
            <summary>
            The <see cref="N:Gemstone.Threading.SynchronizedOperations"/> namespace provides classes and interfaces for
            synchronized operations, which are operations that cannot run while another is already in progress, e.g.,
            <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/> and <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation"/>.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation">
            <summary>
            Represents a short-running synchronized operation that cannot run while it is already in progress.
            </summary>
            <remarks>
            By default, the action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>
            is executed on the <see cref="T:System.Threading.ThreadPool"/> when running the operation asynchronously.
            When the operation is set to pending, the action is executed in an asynchronous loop
            on the thread pool until all pending operations have been completed. Since the action
            is executed on the thread pool, it is best if it can be executed quickly, without
            blocking the thread or putting it to sleep. If completion of the operation is
            critical, such as when saving data to a file, this type of operation should not
            be used since thread pool threads are background threads and will not prevent the
            program from ending before the operation is complete.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.ExecuteActionAsync">
            <summary>
            Executes the action in an asynchronous loop on
            the thread pool, as long as the operation is pending.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.Factory(System.Action)">
            <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory"/> signature.
            </summary>
            <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>.</param>
            <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation"/>.</returns>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase">
            <summary>
            Base class for operations that cannot run while they is already in progress.
            </summary>
            <remarks>
            <para>
            This class handles the synchronization between the methods defined in the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation"/>
            interface. Implementers should only need to implement the <see cref="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync"/> method to provide a
            mechanism for executing the action on a separate thread.
            </para>
            <para>
            If subclass implementations get constructed without an exception handler, applications should attach to the static
            <see cref="E:Gemstone.LibraryEvents.SuppressedException"/> event so that any unhandled exceptions can be exposed to a log.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action)">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase"/> class.
            </summary>
            <param name="action">The cancellable action to be performed during this operation.</param>
            <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase"/> class.
            </summary>
            <param name="action">The action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase"/> class.
            </summary>
            <param name="action">The cancellable action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
            <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning">
            <summary>
            Gets flag indicating if the synchronized operation is currently executing its action.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending">
            <summary>
            Gets flag indicating if the synchronized operation has an additional operation that is pending
            execution after the currently running action has completed.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken">
            <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken"/> to use for cancelling actions.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)">
            <summary>
            Executes the action on current thread or marks the operation as pending if the operation is already running.
            </summary>
            <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
            <remarks>
            <para>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </para>
            <para>
            When <paramref name="runPendingSynchronously"/> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </para>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)">
            <summary>
            Attempts to execute the action on current thread. Does nothing if the operation is already running.
            </summary>
            <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
            <remarks>
            When <paramref name="runPendingSynchronously"/> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync">
            <summary>
            Executes the action on another thread or marks the operation as pending if the operation is already running.
            </summary>
            <remarks>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync">
            <summary>
            Attempts to execute the action on another thread. Does nothing if the operation is already running.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction">
            <summary>
            Executes the action once on the current thread.
            </summary>
            <returns><c>true</c> if the action was pending and needs to run again; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
             <summary>
             Executes the action on a separate thread.
             </summary>
             <remarks>
             Implementers should call <see cref="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction"/> on a separate thread and check the return value.
             If it returns true, that means it needs to run again. The following is a sample implementation using
             a regular dedicated thread:
             <code>
             protected override void ExecuteActionAsync()
             {
                 Thread actionThread = new Thread(() =>
                 {
                     while (ExecuteAction())
                     {
                     }
                 });
            
                 actionThread.Start();
             }
             </code>
             </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)">
            <summary>
            Processes an exception thrown by an operation.
            </summary>
            <param name="ex"><see cref="T:System.Exception"/> to be processed.</param>
        </member>
        <member name="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation">
            <summary>
            Represents a task-based synchronized operation
            that cannot run while it is already in progress.
            </summary>
            <remarks>
            <para>
            The action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation"/> is executed using
            <see cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})"/>. Pending actions run when the task returned by the
            asynchronous action is completed. This synchronized operation only supports the async
            methods on the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation"/> interface because the async action
            cannot be executed synchronously.
            </para>
            
            <para>
            The following example shows how to use <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation"/> to
            implement a notifier that receives notification requests ad-hoc but sends notifications
            no more than once every 15 seconds.
            </para>
            
            <code>
            public ExampleClass() =>
                SynchronizedOperation = new TaskSynchronizedOperation(NotifyAsync);
                
            public void SendNotification() =>
                SynchronizedOperation.RunOnceAsync();
                
            private async Task NotifyAsync()
            {
                Notify();
                await Task.Delay(15000);
            }
            </code>
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation"/> class.
            </summary>
            <param name="asyncAction">The action to be performed during this operation.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation"/> class.
            </summary>
            <param name="asyncAction">The action to be performed during this operation.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.Tasks.Task},System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation"/> class.
            </summary>
            <param name="asyncAction">The action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{System.Exception})">
            <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation"/> class.
            </summary>
            <param name="asyncAction">The action to be performed during this operation.</param>
            <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.IsRunning">
            <summary>
            Gets a value to indicate whether the synchronized
            operation is currently executing its action.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.IsPending">
            <summary>
            Gets a value to indicate whether the synchronized operation
            has an additional operation that is pending execution after
            the currently running action has completed.
            </summary>
        </member>
        <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.CancellationToken">
            <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken"/> to use for canceling actions.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.RunAsync">
            <summary>
            Executes the action on another thread or marks the
            operation as pending if the operation is already running.
            </summary>
            <remarks>
            When the operation is marked as pending, it will run again after the
            operation that is currently running has completed. This is useful if
            an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.TryRunAsync">
            <summary>
            Attempts to execute the action on another thread.
            Does nothing if the operation is already running.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.TaskCompletionSourceFactory">
            <summary>
            Provides factory functions for creating new
            <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> objects.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.TaskCompletionSourceFactory.DefaultTaskCreationOptions">
            <summary>
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions"/> used by this factory
            for creating new <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> objects.
            </summary>
        </member>
        <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1">
            <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> class.
            </summary>
            <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.</typeparam>
            <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.</returns>
        </member>
        <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1(System.Object)">
            <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> class.
            </summary>
            <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.</typeparam>
            <param name="state">The state to use as the underlying <see cref="T:System.Threading.Tasks.Task"/>'s <see cref="P:System.Threading.Tasks.Task.AsyncState"/>.</param>
            <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>.</returns>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.CallbackArgs.StartDisposalCallSuccessful">
            <summary>
            Gets if StartDisposal() method is the only item that triggered this run.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.ThreadContainerBase.State">
            <summary>
            State variables for the internal state machine.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.State.NotRunning">
            <summary>
            Indicates that the task is not running.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.State.ScheduledToRunAfterDelay">
            <summary>
            Indicates that the task is scheduled to execute after a user specified delay
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.State.ScheduledToRun">
            <summary>
            Indicates the task has been queue for immediate execution, but has not started running yet.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.State.Running">
            <summary>
            Once in a running state, only the worker thread can change its state.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.State.AfterRunning">
            <summary>
            Once reaching this state, the effect of RunAgain being set will no longer be valid.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.State.Disposed">
            <summary>
            A disposed state
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerBase.m_runAgainAfterDelay">
            <summary>
            A value less than 0 means false. 
            </summary>
        </member>
        <member name="M:Gemstone.Threading.ThreadContainerBase.StartDisposal">
            <summary>
            Same as Start() except notifies on the callback during a race condition that this is the one that was first to schedule the task.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Gemstone.Threading.ThreadContainerBase.IgnoreShutdownEvent">
            <summary>
            For foreground threads, a shutdown handler is registered to dispose of the Thread so it doesn't keep the process running. 
            However, for the Logger, shutting down this thread will prevent shutdown messages from showing up in the logger. 
            By calling this method, it declares that the coder will dispose of this class when it is finished and does not want the 
            Shutdown handler to do it.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerThreadpool.m_registeredHandle">
            <summary>
            Handle that is created when telling the threadpool to do a delayed start.
            </summary>
        </member>
        <member name="F:Gemstone.Threading.ThreadContainerThreadpool.m_waitObject">
            <summary>
            The reset event that allows the timer to be short circuited.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.WeakAction">
            <summary>
            Provides a weak referenced <see cref="T:System.Action"/> delegate.
            </summary>
            <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.WeakAction.#ctor(System.Action)">
            <summary>
            Creates a WeakAction.
            </summary>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:Gemstone.Threading.WeakAction.TryInvoke">
            <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.WeakAction.Clear">
            <summary>
            Clears <see cref="T:System.Action"/> callback target.
            </summary>
        </member>
        <member name="T:Gemstone.Threading.WeakAction`1">
            <summary>
            Provides a weak referenced <see cref="T:System.Action"/> delegate.
            </summary>
            <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
        </member>
        <member name="M:Gemstone.Threading.WeakAction`1.#ctor(System.Action{`0})">
            <summary>
            Creates a WeakAction.
            </summary>
            <param name="callback">The callback.</param>
        </member>
        <member name="M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)">
            <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
            <returns><c>true</c> if successful; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Gemstone.Threading.WeakAction`1.Clear">
            <summary>
            Clears <see cref="T:System.Action"/> callback target.
            </summary>
        </member>
    </members>
</doc>
